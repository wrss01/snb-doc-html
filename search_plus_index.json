{"./":{"url":"./","title":"产品简介","keywords":"","body":"SmartNoteBook数据分析/数据科学平台介绍 联系咨询:wangxinyi@smartnotebook.tech 借助中国经济的快速发展和数据技术的演进，大数据整个行业实现了生态的完善和技术的飞速发展。大数据从最初在互联网、金融领域应用，到目前相关细分领域也初具规模，有了质的飞跃。未来数据领域如何演进？我们认为未来一段时期需要在以下几方面更多关注： 信息化、数字化到数智化的转变。 信息化是从线下到线上的过程，业务逻辑并没有大的改变，但是极大的提升了业务效率。随着信息化的普及，信息化的深度也随之增强，进而达到数字化阶段，通过信息技术的发展，利用大数据领域大容量存储技术和高效的处理能力，能够将深度信息化带来的数字价值发挥出来，在海量的数据中挖掘出潜在的价值，提升企业的运营效率，快速捕捉用户痛点和需求，实现产品功能的更新迭代，提升竞争力。数据的资产化是企业和国家重视数据的表现，保障数据安全、数据高可用，也是近年来各企业、国家考虑的重点和发展发向。在数字化的基础上，目前互联网公司已经实现了智能化的转变，通过收集用户的行为数据、创建数据模型、挖掘个性化用户喜好和特征，精准化推荐用户需要的商品/内容，是互联网巨头们必备的基础服务。在外卖行业，通过外卖员的行走路线进行数据分析，既能自动规划最短路线，又实现外卖员的负载最大化，也减少了客户的等待时间，实现企业和个人的双赢，促进整个社会效率的提升。未来随着数智化的发展还将促进物联网、自动驾驶、智能物流等领域的快速发展。 数据科学和AI平台建设是企业未来发展的重心。 大数据的广泛应用体现在数据平台、数据仓库和数据中台的建设上，通过这些基础建设挖掘数据价值赋能业务，促进业务的增长。其中数据平台是基础，是存储和计算数据的基石。数据仓库是合理化数据布局，用最少的存储空间实现数据计算效率的最大化。数据中台是建设在数据平台之上，根据业务特性，搭建一站式的数据服务层，用数据赋能业务。这些是最基础的服务，能够给企业带来的价值有限。为了深入的了解业务、洞察痛点、预测行业发展趋势，数据科学和AI平台将是未来发展的重心和方向。通过它深度挖掘算法，预测业务发展规律，提前布局行业发展，实现企业平稳发展。 大数据应以业务、人为中心。 在大数据发展初期，整个行业都在关注与提升技术的先进性，虽然带来了整个行业的进步，但是多少有些舍本逐末，大数据作为一种基础服务，数据和技术是工具，有良好意识和技能的人员，利用数据和工具帮企业实现业务目标才是最终目的，在基础服务层投入较多的人力和成本，不利于企业的良好发展。大数据的发展应以业务和人为中心，这既需要合适的大数据产品或解决方案，又需要培养、提升开发人员、业务人员的数据意识和技能。 On-Premise到SaaS的转变。 On-Premise对大数据平台的搭建很方便，曾经为企业提供了便利，实现管理、监控、诊断和继承等一站式服务，但随着企业对大数据产品功能的要求逐渐增高，这种On-Premise型的服务由于迭代速度慢，版本升级困难，价格贵等因素导致使用这类服务的企业变少。因此更多的企业转向规模更大、服务效率更高、价格更低的SaaS服务。SaaS服务实现了多租户的特性，将成本降至最低；跨越时空的限制，通过互联网满足用户的需求，降低了用户购买硬件资源和聘用运维人员的费用，通过在线服务保障服务质量和服务计量的透明化，在服务的高可用方面提供了较高的保障，对企业来讲用低廉的价格，达到了以往大厂才有的服务和产品功能，在未来，SaaS的优势会越来越明显。 为了适应企业数据化、智能化的需要，结合数智科技的趋势，研发了SmartNoteBook数据分析/数据科学平台，赋能中小企业的数智化能力。以下逐步展开SmartNoteBook数据分析/数据科学平台的介绍。 SmartNoteBook是什么？ SmartNoteBook 是一款现代化的 Notebook，是 开箱即用、云原生、协作式 在线数据科学与分析平台。 SmartNoteBook是参考Jupyter NoteBook思想实现数据科学与分析的强大环境，深度融合Python(编程能力、AI能力)与SQL(数据处理)、可视化于一体，更高效编辑、执行和共享数据应用模型，进行数据采集、探索、机器学习、深度学习和交互可视化。开箱即用的数据科学、机器学习工具包；高效编辑器辅助和团队协作跟踪功能；通过Notebook结构化逻辑关系配合自然语言可以很好表现数据分析过程、阐述数据故事，形成数据报告，深层次的挖掘数据、释放数据价值。 NoteBook企业发行版 基于Notebook思想和企业数据化的需求全新开发了数据分析/数据科学平台:SmartNoteBook,完美兼容NoteBook的显性编程方式(独立代码输入块与显示输出、代码与自然语言标记交织)和Python强大的数据处理、分析和人工智能的框架能力，以下就逐一介绍重点功能： 1.优雅融合SQL数据处理能力： 兼容主流数据库、数据仓库、MPP、HTAP(Hybrid Transaction/Analytics Processing)、大数据平台,利用强大数据基础设施和Python 融合,充分、快速挖掘数据价值。 数据源的统一配置管理、Notebook内引用及调用数据源、DataFrame与SQL互操作、Python与SQL融合等特性，极大提升数据处理效率、降低入门使用门槛。 隐式数据源引用：隐式引用数据源配置为数据连接(Connect)，执行包括数据入库(DataFrame入库操作)、数据处理等(DML或DDL)操作。 SQL单元格(Cell)：选择数据源和编写SQL语句执行后结果集转为DataFrame，提升数据处理效率、降低入门使用门槛。 dfSQL单元格(Cell)：通过SQL操作DataFrame执行数据筛选、过滤、排序、统计汇总、转换、合并等数据处理过程。 SQL模板：SQL及dfSQL支持JinJa2 表达式模板，支持变量替换、逻辑判断、逻辑循环等逻辑控制，可以很方便的结合python 变量控制SQL执行逻辑、支持复杂数据处理逻辑。 Markdown单元格(Cell):通过Markdown描述数据处理的流程、算法的逻辑等说明，更好阐述数据故事和模型、知识的分享。Markdown支持Latex数学公式、插图、序号列表、任务列表、表格、TOC目录等各式，丰富表达数据故事流程。 2.融合Low Code(低代码) 、Full Code、ServerLess理念 使得SmartNoteBook 保持易使用、低门槛的同时，保留数据处理、数据智能化应用无限可能的高天花板。发挥Full Code灵活、扩展性强的特点；保持LowCode(低代码)的自助、低门槛和自助的特征；ServerLess(Function服务)服务模型高效、便捷的构建易维护的数据服务和AI模型服务。 扩展数据转换、数据展示及数据探索的低代码单元格插件，降低数据处理和建模门槛；未来会继续扩展AI/ML插件(coming soon...)。 图表(chart)单元格：支持柱状图、折线图、散点图等，图表是动态交互的，区别于matplotlib、Seaborn静态图；可以单独分享和汇聚到大屏仪表盘(Dashboard)进行分享。 Table单元格：对DataFrame进行数据表格展现，支持筛选、排序、格式定义、分页、列交换。 EDA分析单元格：EDA是探索性数据分析(Exploratory Data Analysis，简称EDA),探索性数据分析（EDA）是一种分析数据集以概括其主要特征的方法，通常使用可视化方法。EDA分析单元格让您更加清晰得洞察数据，通过缩放来查看某一特定的数据。洞悉数据内部特征，帮助窥视不同特征量之间的关系，同时确保数据中没有缺失或是不符合期望的数据。 EDA概览单元格:EDA概览一键生成数据的全貌，简单快速地进行探索性数据分析，包括是数据概要(类型、唯一值、缺失值)、分位数统计(中位数、四分位数等)、描述性统计（标准差、变异系数、偏度系数、众数、均值等）、相关性分析(Spearman's ρ、Pearson's r、Kendall's τ、Phik (φk))可视化(矩阵、色阶图)等。 数据透视表单元格：数据透视表(可以动态地改变它们的配置，以便按照不同方式分析数据，也可以重新设置行、列和值字段)单元格以可视化界面的(类似Excel 透视表 )方式交互聚合和透视数据。拖拽数据集的字段设置行(需要聚合的字段，垂直渲染)、列(需要聚合的字段，水平呈现)、值(需要聚合汇总的字段，配置聚合函数类型：求和、均值、均差等等)敏捷进行数据转换、聚合统计。 3.单一编程界面 代码块：以统一代码块(Cell)组织程序之间或数据间的逻辑关系，形成数据流动的流程图(PipeLine)， 代码块类型包括基本code类型(Python code、SQL code、Markdown)及Low Code 扩展类型(数据转换、数据展示、数据探索分析及不久后支持机器学习)、服务API。 辅助功能:包括节点环境package包管理、数据资源管理(数据文件、数据源及元数据)、目录(根据MarkDown单元格中使用的标题显示Notebook结构和代码的逻辑流程)、节点实例(展示节点实例的负载情况包括cpu、内存等资源，节点环境的切换、Notebook调度配置及调度历史)、变量预览区(变量查看器工具允许您浏览当前NoteBook kernel中使用的变量及其值)、版本控制(版本列表、版本回退、比对、提交;支持gitLab、gitHub)、代码片段(常用复用代码、个人收藏的代码块/代码模板) 模型视图:模型视图是NoteBook 逻辑关系的一种可视化(Graph)关系图展现，节点为单元格，边为单元格之间的引用关系(逻辑依赖关系)，模型视图提升更高效代码执行效率，同时像脑图一样辅助建模人员更好梳理和优化模型、更方便的分享模型。 终端管理:集成的终端web客户端允许您执行许多任务，例如在SmartNoteBook中执行.py脚本，或者使用常见的bash命令访问Node节点环境和文件系统。还可以运行命令并安装需要依赖项的包。 调度/监控(scheduling):使用调度(scheduling)以配置时间间隔（每小时、每天、每周或每月）运行NoteBook。通过调度器可以定期处理数据和更新报告，同时查看和监控执行情况。 4.团队的交互合作 共享和协作是SmartNoteBook中团队合作关键部分。包含WorkSpace工作空间的团队协作、cell和NoteBook 分享、评论。 共享工作空间：让团队用户在您创建的工作空间上协调工作。 共享报告/cell：邀请其他用户实时从默认的主工作区在笔记本上进行协作。随时、多终端分享数据成果。 评论:在NoteBook和报告内对单元格进行评论互动，通过互动快速改进和优化模型。 5.Data/Model service(API) 数据/模型服务是快速将SmartNoteBook建模后的数据或模型生成API服务，通过API为其他业务系统或第三方提供服务(通过数据API的方式，提供给上层数据应用、数据门户，可视化大屏等)，是释放数据价值的最为关键的步骤。由于数据多样性和模型的复杂性，传统的定制开发API方式需要架构、开发、部署、运维等多步骤、多角色参与，整个过程复杂、成本高、运维/维护困难。近几年诞生较多的DataAPI服务平台，通过配置的方式生成API Service，提升效率、降低开发成本，但实际使用过程中也存在较多的问题，比如灵活性问题，很难应对复杂业务场景、很难应对算法模型的数据变换、处理的需要。为此SmartNoteBook开发了FaaS服务模块，Snb FaaS是函数即服务(Function-as-a-Service)的框架，通过NoteBook 调试函数，调试完成直接发布到Snb FaaS Node 节点上直接生成Servcie API，根据负载情况弹性扩展Node 节点。通过FaaS 方式生成Service API 既保持灵活性，又降低复杂性，有极高的弹性，维持灵活性、复杂性和弹性的统一。 云原生的数据分析及数据科学平台 云原生技术使组织能够在公共、私有和混合云等现代动态环境中构建和运行可扩展的应用程序。包括容器、服务网格、微服务、不可变基础设施和声明式 API等。这些技术支持具有弹性、可管理和可观察的松散耦合系统。结合强大的自动化，它们使工程师能够以最少的工作频繁且可预测地进行高影响力的更改。 SmartNoteBook是一款云原生的数据分析及数据科学平台，适应于公有、私有及混合云，有较好的弹性，根据需要配置Node 节点的资源、隔离WorkSpace,使用SmartNoteBook 快捷构建组织内的数据分析和数据科学环境和生态。 云原生的架构：整体架构包括Server(管理)、Node(分析及计算引擎)、Kernel Plugin模块，应用云原生的中间件。 以工作空间(WorkSpace)为单元做资源管理、隔离和弹性部署。 安装和部署全部容器化的，可以利用容器编排工具管理集群。 模型市场及知识社区 "},"QuickStart.html":{"url":"QuickStart.html","title":"快速上手","keywords":"","body":"快速上手 概述 SmartNoteBook（产品简称：SNB） 是一款现代化的NoteBook，是开箱即用、云原生、协作式在线数据科学与分析平台。使用SNB您可以简化数据洞察和交付，帮助数据科学和业务团队共同提高数据分析效率。 您可以连接任何您所需的数据形式（如数据文件、数据仓库、图数据库、数据开放平台API等），并以一种崭新的方式开展数据分析和数据探索、建立预测模型、注册服务、创建知识图谱、数据可视化并生成数据报告或创建仪表盘...实现从数据接入到数据价值的全流程，让数据触手可及，畅通无阻！ SNB主要汇集了以下要点： 集成主流的机器学习框架和 AutoML 框架 支持对多种数据科学语言的编码和环境：如 Python、SQL、R、SageMath 和 Julia 等 对主流数据库、数据仓库、图数据库以及数据开放平台的集成支持和管理 深度融合SQL 和 Python 两大最流行的数据科学语言，用户能够在数据分析过程中自由切换 提供零代码的数据转换和可视化分析组件 快速生成现代商业智能和交互式的数据服务和应用 模型视图(Graph)促进模型的可解释性和再现性 团队成员在WorkSpace中的开展实时协作 “一模多用” ...... 以下我们通过三个步骤快速掌握SmartNoteBook的最基础使用。 第一步 通过创建和编辑您的第一个NoteBook开始学习数据知识。 在WorkSpace下创建新的NoteBook 1.在WorkSpace下，单击左下方的“新建NoteBook”，您将重定向到“新建NoteBook”页面。 2.输入标题，并选择相应的环境，然后点击提交。 3.创建完成，进入到核心的NoteBook页面。 目前，您的NoteBook仅包含一个Python代码单元格。默认情况下，它会显示这样一段欢迎代码： 编辑笔记本 1.我们在第一个代码单元格中，输入以下代码。 # 获取当前时间 import datetime now = datetime.datetime.now() print('现在几点钟了？') print('当前时间：',now) 2.点击左上角的运行按钮 或按下快捷键 Ctrl/Shift+Enter 来运行代码块。 3.将鼠标悬停在单元格下边框的中间区域，选择更多类型我们可以看到更多的单元格类型或组件。比如我们添加一个 Markdown单元格。 4.在Markdown单元格中输入文本，然后按下快捷键 Ctrl/Shift+Enter 运行。 5.如果要完整运行整个NoteBook代码，请选择上方菜单栏的运行并点击全部运行。 第二步 使用您的数据 按照以下步骤附加csv文件数据并执行基本的分析。 1.下载鸢尾花数据集Iris.csv（此数据集据集包含150个数据样本，分为3类，每类50个数据，每个数据包含Id列、花的4个属性以及花的分类）。 2.点击WorkSpace主页右上角的的上传文件按钮，将下载的数据集上传至云端。 3.进入NoteBook，单击左侧边栏上的数据资源图标 ，在WorkSpace文件下可以看到上传的Iris.csv，点击右上角“文件一键同步到Node”，此时页面上方提示文件同步成功。 4.使用 Pandas（一种流行的 Python 库）查看数据。 在任意Python单元格中粘贴以下代码： import pandas as pd iris_data = pd.read_csv('/home/Iris.csv') iris_data 运行代码单元后，输出区域将显示如下表： 可视化数据集 新建一个Python单元格，贴入以下代码： import seaborn as sns import matplotlib.pyplot as plt %matplotlib inline plt.figure() sns.pairplot(iris_data.drop(\"Id\", axis=1), hue = \"Species\", height=3, markers=[\"o\", \"s\", \"D\"]) plt.show() 运行代码块后，会显示如下所示的图表： 第三步 分享您的分析报告 1.单击NoteBook右上角的分享图标 。 2.复制分享链接发送分析报告。 按钮。 --> 3.（可选）如果需要单独分享某个单元格输出，只需点击该单元格右侧的分享 按钮。 接下来... 开始发挥您的创意。您可以先查看SNB为您准备的一些demo，然后自己创建一个新的NoteBook，尽情发挥想象力。 连接数据源或上传您自己的数据。访问数据源以连接数据库或数据仓库，或者上传CSV、XLS/XLSX文件。 使用SNB提供的代码单元格和各类可视化分析组件提升效率，降低门槛。 邀请成员一起工作，并相互分享见解。 "},"WorkSpace/main.html":{"url":"WorkSpace/main.html","title":"WorkSpace","keywords":"","body":"WorkSpace（工作空间） 概述 WorkSpace（工作空间）是SNB的中央组织单位。它就像SNB的大管家，集合了团队成员在同一个组织内的各类资源要素，如NoteBook模型文件、数据资产、环境资源等等，帮助我们更好地组织和管理数据分析工作。 功能列表 功能 解释 您的NoteBooks WorkSpace所有NoteBook模型文件列表。详见您的NoteBooks 最近的NoteBooks 本账号最近浏览NoteBook文件记录列表。详见最近的NoteBooks 删除的NoteBooks 本登陆账号最近删除的Notebook文件记录列表（支持一键恢复）。详见删除的NoteBooks 数据源 数据源的连接与管理。详见数据源 数据文件 文件的上传与管理（上传到WorkSpace）。详见数据文件 密保箱 配置key-value全局变量或加密敏感信息。详见密保箱 计算环境 NoteBook运行环境的配置与管理。详见计算环境 调度器 用于设定并管理NoteBook模型文件的定期运行，查看运行结果。详见调度器 服务API 用于管理已注册的服务API、测试与使用服务API。详见服务API 专题分析 展示了你保存时要分析的数据集，可以在这里继续你的自助探索或分析。详见专题分析 图表管理 自助分析过程中保存的图表列表。详见图表管理 报告和看板 查看并管理已创建的数据报告与看板。详见报告和看板 门户管理 门户管理指的是管理一个系统的门户应用程序。门户是用户进入报表系统主要入口点， 提供了访问各种信息、服务和功能的统一界面。详见门户管理 WorkSpace成员 成员管理。详见成员 WorkSpace设置 管理WorkSpace的相关配置。详见WorkSpace设置 WorkSpace日志 WorkSpace日志管理，提供搜索，查询。详见WorkSpace日志 模板管理 模版管理为了高效构建仪表盘，我们提供快捷的建立，编辑，和管理模版的功能。详见模版管理 相关操作 用户成功登录SNB后，会进入到系统默认的WorkSpace工作空间。 修改Workspace信息 点击WorkSpace设置，进入WorkSpace的设置界面，然后点击编辑按钮。 在这里您可以修改您自己的WorkSpace名称与描述，配置代码仓库（配置方式详见WorkSpace设置 ），并上传您喜欢的头像。一切配置完成后记得点击保存。 功能 解释 WorkSpace 名称 名称，必填项 WorkSpace 描述 描述，选填项 仓库类型 选填配置， 目前支持的仓库类型：gitlab 和 github 仓库地址 配置git仓库的url，格式如：http://172.30.81.xxx:8000 仓库token 配置git仓库的Access Token 仓库ID或目录 配置git仓库的ID或目录 分支 配置git仓库的分支 头像 单击上方＋上传新的头像 测试仓库链接（按钮） git仓库配置完成后，点击测试是否成功 创建新的WorkSpace 单击左上角WorkSpace的下拉箭头，点击新建WorkSpace 然后输入新的WorkSpace的相关信息和配置，点击提交，新的WorkSpace创建完成。 切换WorkSpace 当用户拥有或加入了多个WorkSpace时，如需切换，可点击左上小三角切换至需要的WorkSpace。 "},"WorkSpace/NotebookTable.html":{"url":"WorkSpace/NotebookTable.html","title":"您的NoteBooks","keywords":"","body":"你的NoteBooks 管理当前WorkSpace下所有的NoteBook模型文件。 新建文件夹 点击右上角的文件夹图标 新建文件夹。文件夹帮助我们更好的组织和管理NoteBook文档，便于归档和查找 修改文件夹/NoteBook名称 鼠标移至名称一栏，点击编辑图标对名称进行修改（修改NoteBook名称也可在进入NoteBook文档后在页面上面修改） 拖动文件夹/NoteBook 鼠标左键在文件夹或NoteBook文档上按住约3秒直到可以拖动，此时可以拖动文件或文件夹到其他文件夹，实现对NoteBook文件和目录的组织和管理。 NoteBook的操作 点击NoteBook文档操作一栏的...，可以看到以下操作命令： 操作 解释 重命名 重新修改NoteBook文档名称 新的窗口打开 浏览器开启新的标签页打开此NoteBook文档 创建副本 在当前目录下创建文档副本 收藏 收藏文档后文档将显示收藏图标 并在列表中置顶显示 导出.snb 导出snb格式文件（SmartNoteBook专用格式） 导出.ipynb 导出.ipynb文件(兼容Jupyter NoteBook) 删除 将文档放入删除的NoteBook 列表 "},"WorkSpace/RecentVisits.html":{"url":"WorkSpace/RecentVisits.html","title":"最近的NoteBooks","keywords":"","body":"最近NoteBooks记录 快捷查看最近打开过的NoteBook文档。 支持的操作有： 双击打开NoteBook文档 新的窗口打开：浏览器开启新的标签页打开此NoteBook文档 导出.snb：导出snb格式文件（SmartNoteBook专用格式） 导出.ipynb：导出.ipynb文件(兼容Jupyter NoteBook) "},"WorkSpace/RecentDel.html":{"url":"WorkSpace/RecentDel.html","title":"删除的NoteBooks","keywords":"","body":"删除的NoteBooks 查看删除过的NoteBooks 在操作下点击恢复可找回误删的NoteBook文档 "},"WorkSpace/DataSource.html":{"url":"WorkSpace/DataSource.html","title":"数据源","keywords":"","body":"数据源 简单、高效、无代码的与数据源建立安全链接。 --> 数据源类型 SmartNoteBook 目前已经过测试支持的数据源类型包括： MySQL：关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一。 Spark：通用的大数据分析引擎,具有高性能、易用和普遍性等特点。 Hive：基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。 PostgreSQL：一种特性非常齐全的自由软件的对象-关系型数据库管理系统（ORDBMS） Oracle：甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。 SQL Server：SQL Server是由Microsoft开发和推广的关系数据库管理系统（RDBMS）。 Presto：Facebook开发的数据查询引擎，可对250PB以上的数据进行快速地交互式分析。 ClickHouse：俄罗斯的 Yandex 于 2016 年开源的用于在线分析处理查询（OLAP :Online Analytical Processing）MPP架构的列式存储数据库 Greenplum：业界最快最高性价比的关系型分布式数据库，它在开源的PG(PostgreSql)的基础上采用MPP架构（Massive Parallel Processing,海量并行处理），具有强大的大规模数据分析任务处理能力。 Neo4j：Neo4j是一个开源的，高性能的NoSQL图形数据库。 DuckDB：DuckDB是一个针对数据分析和查询任务进行优化的高性能列式存储数据库管理系统，它提供了快速的查询性能、低内存占用以及方便的SQL查询功能。 MindsDB：MindsDB是一个开源的机器学习库，用于使数据科学家和开发人员能够轻松地将机器学习模型集成到其现有项目和工具中。通过MindsDB，用户无需深入了解机器学习的复杂细节就可以训练和部署模型。MindsDB结合NoteBook的使用教程可以参考MindsDB(SQL+ML)实战案例 MongoDB：一种面向文档的NoSQL数据库，由MongoDB Inc. 开发和维护。MongoDB 以其高性能、高可用性和易扩展性著称，支持多种数据模型，包括键值、文档和图等。它特别适合需要快速开发和处理非结构化数据的应用程序。 TiDB：PingCAP 开发的一款开源分布式数据库，兼具传统关系型数据库的特性和分布式数据库的优点。TiDB 支持标准的 MySQL 协议，并具有高可用性、水平扩展性和实时 HTAP（Hybrid Transactional/Analytical Processing）能力，非常适合大规模在线事务处理（OLTP）和在线分析处理（OLAP）场景。 [!NOTE] 即将支持更多数据源类型 —— 目前，SNB正在积极进行国产数据库接入测试的工作。如果您有需要优先支持的数据源，可通过邮件联系我们 feedback@smartnotebook.tech。 新建数据源连接 选择左侧导航栏的数据源，然后点击页面右上角新建连接服务。 我们选择需要连接的数据源图标并填写相应的连接及密码验证信息： 当信息填写完毕后先点击测试，如连接信息有误，系统会返回相应的错误提示。如返回连接测试成功，表明数据库连接成功，此时点击提交，一个新的数据源连接就建好了。 不同数据源的信息配置 对于MySQL，PostgreSQL，SQL Server，ClickHouse、Greenplum、Neo4j、MindsDB、MongoDB 和TiDB，您需要配置： 连接名称 数据库主机网址地址（host） 数据库端口（Port） 数据库名称（Database） 用户名和密码 对于Spark，Hive和Presto，您需要配置： 连接名称 数据库主机网址地址（host） 数据库端口（Port） 数据库名称（Database） 鉴权方式：用户名和密码或无需鉴权 用户名和密码 对于Oracle，您需要配置： 连接名称 数据库主机网址地址（host） 数据库端口（Port） 实例名（SID） 驱动类型（driver）：Thin/OCI/OCIB 用户名和密码 对于DuckDB，您需要配置： 连接名称 文件路径（无需鉴权）：db文件上传至SNB，并复制其在SNB的路径 数据资源 --> 使用数据连接查询数据库 当建立好数据连接后，可以在NoteBook中使用SQL单元格进行查询。详见SQL单元格 配置SSH安全连接 当你无法直接访问内网的数据资源，或者需要从外部网络安全地访问内网的数据资源时，可以通过建立 SSH 隧道的方式连接跳板机（堡垒机），进而安全的访问内网资源。 以下是SSH配置参数的说明： 主机地址（SSH Host）：这是您要连接的远程主机（堡垒机）的主机名或IP地址。它可以是您想要远程访问的服务器或网络设备。 端口号（SSH Port）：SSH协议通常使用22端口作为默认端口。当您连接到远程主机时，您可以指定要使用的端口号。在某些情况下，您可能需要更改默认端口以增加安全性。 用户名（SSH User）：您需要指定您在远程主机上的用户名。这是您在远程主机上拥有访问权限的帐户。 密码（SSH Password）：为了进行身份验证，您需要提供与所指定用户名相对应的密码。这是为了确保只有授权用户可以访问远程主机。 配置SSH信息后，如果你想访问内网的数据库，则需要配置内网数据库的 IP 地址。在配置连接参数时，你需要指定内网数据库的 IP 地址、端口号以及其他必要的凭据（如用户名和密码）。 [!Tip] 在配置SSH连接参数之前，务必确保跳板机（堡垒机）能够无障碍地访问数据服务器。您可能需要与系统管理员或网络团队紧密合作，他们需要正确设置网络配置、防火墙规则和访问控制等，以确保正确配置并确保安全地访问内网数据库。 "},"WorkSpace/Files.html":{"url":"WorkSpace/Files.html","title":"数据文件","keywords":"","body":"WorkSpace文件 将本地（数据）文件上传至 SNB。 上传文件 选择左侧导航栏的WorkSpace文件，点击右上角上传文件按钮，弹出选择文件窗口。 选择要上传的文件（注意：单个文件大小不超过10M)，单击打开，即刻开始上传文件。 下载文件 在文件列表中找到需要下载的文件，单击操作列的...，然后点击下载，即刻开始文件下载。 新建文件夹 点击文件列表右上角的文件夹图标 创建新的文件夹。 重命名文件夹 方式一：选择需要重命名的文件夹，单击操作列的...，点击重命名，修改好文件夹名称后点击√提交修改。 方式二：鼠标移动到需要重命名的文件夹名称处， 此时出现编辑按钮，点击编辑按钮对文件夹重命名后点击√提交. 删除文件（夹） 选择需要删除的文件（夹），单击操作列的...，然后点击删除。 [!warning|style:flat] 删除文件夹时需确保文件夹内容为空，否则无法删除。 同步文件 文件一键同步到Node 在Workspace文件页面上传，文件将会上传至公共区域，在侧边栏-数据资源-WorkSpace文件点击文件一键同步到Node，公共区域的资源文件会同步至Node节点使用。（同步至多个环境） 详见 侧边栏-数据资源-WorkSpace文件 直接上传文件至Node 详见 侧边栏-数据资源-环境文件 读取文件 预览csv文件 详见 侧边栏-数据资源-环境文件 单元格读取csv文件 详见 SQL代码块-dfSQL "},"WorkSpace/Encryption.html":{"url":"WorkSpace/Encryption.html","title":"密保箱","keywords":"","body":"变量密保箱 变量密保箱的用处： 将敏感值（如API令牌或重要密码）加密 作为全局变量使用 建立密保/变量后，用户可以在NoteBook中通过名称访问密保/变量的值，而不是通过明文或者硬编码的方式进行调用。 新建密保/变量 点击右上角的新建变量,输入名称（英文）和值。 如需加密请勾选加密，配置完成后点击提交。 密保/变量列表 在列表处对已有的密保/变量进行编辑或删除： 密保/变量的使用 复制密保/变量 单击名称复制密保/变量 使用密保/变量 在Python单元格中使用密保： 在MarkDown中使用变量： 作为CSS样式使用: 详见设置MarkDown的标签样式（高级用法） "},"WorkSpace/Environment.html":{"url":"WorkSpace/Environment.html","title":"计算环境","keywords":"","body":"环境 概述 环境是NoteBook运行所需的计算资源和软件（包）配置的组合，包含了硬件配置以及我们所需的镜像类型。 硬件配置决定了可用的计算资源，如CPU的处理能力、内存的容量和存储的大小，这些配置会对产品的性能和扩展能力产生影响。 而镜像类型则决定了NoteBook所使用的软件环境。镜像包含了预先安装的操作系统、软件库、依赖项和配置，以满足特定的开发或运行需求。 例如，Python基础版的镜像可能包含了Python解释器和一些常用的Python库，适用于一般的Python应用开发；而Python机器学习版的镜像额外预装了机器学习框架（如TensorFlow、PyTorch等）以及其他常用的数据科学库，以满足机器学习项目的需求。 [!NOTE] SNB 使用了容器化技术（Docker）打包和部署每个微服务及其依赖项，可以根据需求自动调整Node节点的数量和规模，以适应模型运行时的负载变化。当客户开始进行模型训练时，SNB 可以监测到训练任务的资源需求，并根据需求动态地调整系统的资源配置。这样，客户无需手动管理和调整资源配置，只需专注于模型训练本身。 新建/编辑环境（专业版或企业版） 选择左侧导航栏的环境，单击新建环境配置，选择型号配置和镜像类型并填写环境名称提交。 如需修改环境配置，可单击操作列的...，然后点击编辑环境，修改完成后提交。 [!NOTE|style:flat] 专业版或企业版的管理员拥有此功能权限，基础版无此功能。 查看和关闭Kernel实例 单击环境列表前的 可查看该环境下所有打开的Kernel实例。 如需关闭实例，可以选择相对应的NoteBook，点击右侧的关闭并确定。 [!NOTE|style:flat] 如果 kernel 实例在当前环境中超过 12 小时没有被使用，系统将会自动释放该 kernel 实例以节省资源。 环境状态 环境拥有两种状态： 正常：环境按照预期的方式工作，没有出现任何错误或故障 异常：环境发生了一些不寻常或不符合预期的情况，可能无法正常工作，功能可能受限或完全无法使用。 查看环境的运行和使用状态 详见侧边栏的环境-查看配置/负载情况 切换环境 详见侧边栏的环境-切换环境 删除环境 在WorkSpace环境标签页，找到需要删除的环境，单击操作列的...，然后点击删除。 [!Warning] 注：如环境已被使用，需将此环境下所有的NoteBook删除后才可删掉环境。 "},"WorkSpace/Schedule.html":{"url":"WorkSpace/Schedule.html","title":"调度器","keywords":"","body":"调度器 设定调度器会安排NoteBook按计划（如每小时/天/周/月）间隔重复运行。 注意以下几点： 在创建调度器时，需保证此NoteBook至少已经保存了一个版本(如未保存版本，SNB会将当前内容自动保存一个版本运行) 调度器执行时，将从上到下执行整个NoteBook的逻辑。如NoteBook中有单元格报错，会继续执行后面单元格的代码（当然，如果后面单元格的代码依赖前面报错的单元格结果，则后面的单元格也会报错） 当一个NoteBook拥有多个版本记录时，调度总是执行最新保存版本的代码。 [!NOTE] 一个 NoteBook 在单个环境上只能配置一个调度器（计划），但如果您有多个环境，您可以在每个环境上为同一个 NoteBook 配置多个调度器（计划）。这样，您可以在不同的环境中灵活地管理和调度同一个 NoteBook 的执行。 创建调度 在NoteBook文档内，点击左侧侧边栏的环境 按钮。 点击最下方的去创建调度器 设置执行周期，可以安排每小时、每天、每周或每月定期执行。 在高级设置中，可以选择配置计划运行完成时状态成功或失败的通知，以及哪些用户将收到这些通知。 样例： 设定每天 10:15 执行，无论执行成功或失败均通知管理员admin@xxx.com 立即执行调度 设定调度执行，如果想立刻查看调度的运用结果那么，你只用点击立即执行按钮。 查看历史 单击调度器列表中某条记录，可以查看该调度器执行的历史执行情况。 同时，在这个页面，你也可以查看、下载和删除历史运行结果。 如需调整调度设置可点击右侧的调度器设置来重设执行计划。 打开NoteBook 快捷跳转打开调度器对应的NoteBook文档。 暂停/恢复调度 以下几种方式均可暂停/恢复调度 1.在NoteBook文档内，点击左侧侧边栏的环境 按钮，下方开关可暂停/恢复调度： 2.在WorkSpace下的调度器列表选择需要暂停的任务点击...后选择暂停调度，可以暂停调度： 3.在调度器运行历史的页面也可以通过开关快捷暂停/恢复调度： 运行结果 运行结果记录了NoteBook中代码运行结果和相关信息的文档。 点击调度器列表的某条记录，弹出该调度器的历史运行记录，在此我们可以查看、下载和删除历史运行结果。 查看运行结果 点击查看运行结果跳转至结果页面： 下载运行结果 将导出运行结果的.snb文件 删除运行结果 删除历史运行结果 [!Warning] 删除的历史结果无法恢复，请谨慎操作！ 删除调度 在WorkSpace下的调度器列表选择需要删除的调度，点击...后选点击删除调度。 [!Warning] 删除调度前需确认任务是否正在执行，否则会提示删除失败。 切换查看不同环境下的调度器 调度器标识 配置调度器后的NoteBook名称右侧会增加圆点标识 "},"WorkSpace/FaasService.html":{"url":"WorkSpace/FaasService.html","title":"服务API","keywords":"","body":"服务API 数据/模型服务是快速将SmartNoteBook建模后的数据或模型生成API服务，通过API为其他业务系统或第三方提供服务(通过数据API的方式，提供给上层数据应用、数据门户，可视化大屏等)，是释放数据价值的最为关键的步骤。 由于数据多样性和模型的复杂性，传统的定制开发API方式需要架构、开发、部署、运维等多步骤、多角色参与，整个过程复杂、成本高、运维/维护困难。近几年诞生较多的DataAPI服务平台，通过配置的方式生成API Service，提升效率、降低开发成本，但实际使用过程中也存在较多的问题，比如灵活性问题，很难应对复杂业务场景、很难应对算法模型的数据变换、处理的需要。 为此SmartNoteBook开发了FaaS服务模块，Snb FaaS是函数即服务(Function-as-a-Service)的框架，通过notebook 调试函数，调试完成直接发布到Snb FaaS Node 节点上直接生成Servcie API，根据负载情况弹性扩展Node 节点。通过FaaS 方式生成Service API 既保持灵活性，又降低复杂性，有极高的弹性，维持灵活性、复杂性和弹性的统一。 注册API 注册样例： import requests import json __MODULE_NAME__ = \"Translate\" def translate(word:str=\"word\") -> \"HTTP\": \"\"\" { \"input\":{\"word\":{\"type\":\"string\",\"default\":\"word\"}}, \"output\":{\"type\":{\"type\":\"string\", \"default\":\"EN2ZH_CN\"}, \"errorCode\":{\"type\":\"integer\", \"default\":0}, \"elapsedTime\":{\"type\":\"integer\", \"default\":1}, \"translateResult\":{\"type\":\"array\",\"items\":\"\",\"default\":{\"src\": \"word\", \"tgt\": \"词\"}}} } \"\"\" url = f\"https://fanyi.youdao.com/translate?&doctype=json&type=AUTO&i={word}\" header = { \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\", } response = requests.get(url=url, headers=header) output = json.loads(response.text) return output 格式约定： __MODULE_NAME__：Faas API名称。变量名固定，值由用户自定义（不允许重复） def translate(word:str=\"word\") -> \"HTTP\":: 函数名和参数用户自定义 函数返回值为json数据类型 除上述约定外，函数内部代码用户自定义编写 函数在单元格中定义完成后，点击...-->注册服务API进行注册： 注册成功： [!NOTE] 同一环境下服务API注册名称（MODULE_NAME）不可重复，不同环境下服务API注册名称（MODULE_NAME）可以相同。 管理API 点击WorkSpace下的服务API，可以看到已注册的API列表。 在此我们可以进行的操作有： 打开NoteBook：打开服务API对应的NoteBook文档 帮助文档：打开该API的帮助文档（支持接口测试） 删除服务：删除该API ：复制API链接地址 切换查看不同环境下的API 点击列表右上角的环境标签可切换查看在不同环境下注册的服务API： 使用API 我们点击API的帮助文档 跳转到API的帮助页面，接下来可以查看接口的地址、参数信息和调用方法等，并尝试修改参数来调试调用接口 请求参数： 出参格式： 调用测试： 1.点击按钮 2.修改参数内容，点击执行 3.接口实际返回结果 接口测试没问题后，我们便可以来实际调用使用了。 "},"WorkSpace/Subject.html":{"url":"WorkSpace/Subject.html","title":"专题分析","keywords":"","body":"专题分析管理 查看 点击进入可以看到该专题的字段列表区域展示了你保存时要分析的数据集，可以在这里继续你的自助探索或分析。 创建 专题来源于自助分析组件，先添加一个“自助分析”组件， 接着选择事先准备的数据集，按需调整配置项，然后点击该组件单元格右边的保存专题图标，然后在弹出的对话框中输入专题名称,点击“提交”，即可保存该专题。 修改专题/配置权限 在专题列表中可以修改专题的名称和发布状态，也可以配置该专题分析的查看权限，规则是设置谁可以看，只有勾选过的用户才可以查看该专题。 编辑 删除 "},"WorkSpace/ChartLib.html":{"url":"WorkSpace/ChartLib.html","title":"图表管理","keywords":"","body":"图表库管理 图表上传 点击自助分析组件中工具栏上的图标按钮； 在弹出的对话框中，点击“上传”按钮，输入“图表名称”和选择“开放状态”，完成后点击“提交”，即可将图表上传至图表库中。 说明： 开放状态包括自己访问、WorkSpace内访问和开放访问三种。自己访问：表示该图表是私密的，只能由你访问；WorkSpace内访问：是指同一个WorkSpace的成员都能访问；开放访问：是指任何人都能访问。 图表查看/修改 上传的图表可以从图表管理页面中查看，可以进入接着探索数据。 可以在这里修改图表的名称和开放状态。 "},"WorkSpace/Dashboard.html":{"url":"WorkSpace/Dashboard.html","title":"报告和看板","keywords":"","body":"报告和看板 报告和看板列表，允许用户查看和分享工作空间下已发布的仪表板。 制作和发布仪表板的步骤参见仪表板。 查看仪表板 单击仪表板名称，在新的标签页查看对应的仪表板内容。 相关操作 点击列表操作一栏的...，查看支持的操作指令： 打开NoteBook 快捷打开仪表板对应的NoteBook文档。 分享链接 点击可复制仪表板的分享地址，将仪表板通过地址分享给他人或嵌入到数据门户及应用。 删除 删除所选的仪表板。 [!Warning] 删除的仪表板无法恢复，请谨慎操作！ "},"WorkSpace/PortalTion.html":{"url":"WorkSpace/PortalTion.html","title":"门户管理","keywords":"","body":"门户管理 门户管理指的是管理一个系统的门户应用程序。门户是用户进入报表系统主要入口点， 提供了访问各种信息、服务和功能的统一界面。以下是门户管理的页面： 新增菜单 [!Warning] 注：新增菜单有两个层级（一级菜单在菜单栏中显示，二级菜单为子菜单）。 新增一级菜单：点击屏幕右上角+菜单按钮，如下图绿色按钮 新增子菜单：在列表中点击一级菜单操作中的添加子菜单按钮，如下图 弹出下图弹框 字段设置 字段设置 解释 是否必填项 页面名称 门户菜单显示的名称 示例1 是 页面标识（英文） 英文标识 是 生成菜单 是否在门户菜单中显示 是 隐藏头部 门户中打开页面是否显示菜单头部 是 排序 门户菜单中显示的顺序 示例2 否 看板 选择已经发布的报表 示例3 是 报表链接 选择看板之后自动生成报表链接 示例3 是 权限设置 设置workspace成员可查看权限 示例4 是 备注 备注 否 示例 示例1 名称展示 示例2 门户菜单中显示的顺序 示例3 选择已经发布的报表 示例4 权限 编辑菜单 如果菜单需要修改，那么点击对应菜单列表的编辑按钮 删除菜单 删除菜单，那么点击对应菜单列表的删除按钮， 删除菜单后，门户当中找不到此菜单页面，成员也不能通过链接访问。 此操作不可逆，请谨慎操作。 第二次确认删除弹框，如果删除则点击确定，反之则点击取消。 确定删除数据不能恢复！请谨慎。。。 "},"WorkSpace/Groups.html":{"url":"WorkSpace/Groups.html","title":"WorkSpace成员","keywords":"","body":"WorkSpace成员 团队成员在相同的WorkSpace下开始协同工作。 邀请团队成员 单击页面右上角的按钮转到邀请页面，填写受邀请用户的Email并设置其角色（编辑者/查看者），点击发送邀请： 发送邀请后，被邀请的团队成员状态将显示为\"邀请中...\"： 被邀请成员点击邮件确认后状态切换为\"正常\"，此时被邀请人加入该WorkSpace并获得相应的权限参与到协同工作。 [!NOTE|style:flat] 受邀请用户需要先成功注册SNB的账号，否则无法接收邀请： 修改角色权限 编辑者：拥有除WorkSpace设置以及环境资源配置外，其他一切该WorkSpace拥有者的权限（查看、新建、编辑、删除） 查看者：看到的功能与编辑者一致，但只拥有查看权限 管理员可以对状态正常的成员修改角色权限： 移除成员 管理员可以在成员列表中点击操作-移除将已加入的成员移除出团队。 被移除的成员将无法看到该WorkSpace，如需重新访问，需被重新邀请。 禁用 管理员可以对成员的状态进行修改（禁用）。 被禁用的成员将无法看到该WorkSpace直到状态被修改为正常状态。 实时协作 SNB支持实时协作模式，允许团队成员实时跟踪代码的编写进度。 在这个模式下，首位进入NoteBook的团队成员将获得编辑权，其他成员则可以即时查看其编码过程。这一设计特点不仅便于团队间的沟通协作，更使教学过程变得直观易懂：学生可以清晰地看到老师的编程逻辑，从而更好地吸收知识。 SNB的实时协作模式通过促进信息同步，极大地提升了用户的交互体验。 [!TIP] 所有进入NoteBook的团队成员，头像将出现在NoteBook的右上角。 "},"WorkSpace/Settings.html":{"url":"WorkSpace/Settings.html","title":"WorkSpace设置","keywords":"","body":"WorkSpace设置 用于配置WorkSpace的头像，名称,备注,仓库类型,仓库地址,仓库token,仓库id 编辑/新建/切换WorkSpace 编辑当前WorkSpace信息 当前WorkSpace下点击左侧菜单栏WorkSpace设置-->编辑。 可修改WorkSpace的名称和描述，并上传喜欢的头像，点击保存。 功能 解释 WorkSpace 名称 必填 WorkSpace 描述 选填 仓库类型 选填， 目前支持的仓库类型：gitlab 和 github 仓库地址 git仓库的url，如：http://172.30.81.xxx:8000 仓库token git仓库的Access Token ，获取方式见下方的tips 仓库ID或目录 git仓库的ID或目录 分支 git仓库分支 测试仓库链接 git仓库配置完成后，点击测试是否成功 WorkSpace 图标 单击上方的图标修改并上传新的图标 如何获取gitlab的Access Token？ 登录gitlab，点击Settings-->Access Tokens，并按照页面填写信息和勾选权限后，点击下方的绿色按钮 Token创建成功，复制使用 如何配置github？ 1.登录GitHub，点击右上角的头像选择Settings 2.左侧菜单点击Developer settings 3.点击Personal access tokens-->Tokens(classic)-->右上角按钮Generate new tokens(classic) 4.填写Note（必填）、选择过期时间Expiration，并勾选权限范围，鼠标滑到页面最下方点击绿色按钮Generate token 5.复制Access Token 6.复制仓库ID或目录 7.将上面拿到的Access Token和仓库目录以及分支信息填入WorkSpace的仓库设置，点击按钮测试仓库链接，如配置正确系统会提示连接成功，点击保存即可。 删除 [!Warning] 注：删除WorkSpace时，如该WorkSpace下如存在任何文件或使用记录，需将所有内容删除后才能删除。 "},"WorkSpace/Logging.html":{"url":"WorkSpace/Logging.html","title":"WorkSpace日志","keywords":"","body":"WorkSpace日志 访问日志在工作空间中起着重要的监控、追踪、排查和优化作用，有助于提升系统的安全性、稳定性和性能，同时也为业务决策提供了重要的数据支持。 列表展示信息 功能 解释 访问账号 前端请求服务的登陆账号名称 访问模块 服务代码的模块名称 访问IP 访问的IP 访问时间 访问的时间 访问地址 访问地址全路径 日期筛选功能 选择起始日期和结束日期，以便限制查询范围。 日期组件如图： "},"WorkSpace/DashboardTemplates.html":{"url":"WorkSpace/DashboardTemplates.html","title":"模版管理","keywords":"","body":"模版管理 模版管理为了高效构建仪表盘，我们提供快捷的建立，编辑，和管理模版的功能！通过系统化的模版管理，可以大大提高工作效率，确保输出的一致性和专业性，满足组织的各项需求。以下是模版管理的页面： 新增模版 新增模版：点击屏幕右上角+模版按钮，如下图绿色按钮 弹出下图弹框 字段设置 字段设置 解释 是否必填项 模版分类 模版分类 示例1 是 模版名称 模版名称 是 默认宽度 模版默认宽度 是 默认高度 模版默认高度 是 设置配置项 设置模版的各个自定义属性 示例2 否 模版内容 HTML模版和变量 示例3 是 上传示例图表 上传模版图片以供查看 是 预览示例 模版默认样式 否 示例 示例1 模版类型 模版类型 模版子类 仪表板UI控件 标题控件、背景框控件、文本框控件、装饰控件 交互控件 输入框、下拉框、标签框、单选框、单选框、时间日期、按钮 仪表板主题 仪表板模版 模版页 模版页-登录页、模版页-Protal首页 示例2 模版设置配置项 示例3 模版内容 // 仪表板UI控件 ${title} // 交互控件 {\"fontSize\":12,\"isbold\":0,\"color\":\"#EE1E23\",\"width\":50,\"height\":30, \"border\":0,\"borderColor\":\"#1B3A74\",\"borderWidth\":0,\"borderRadius\":2, \"background\":0,\"backgroundColor\":\"#1B3A74\",\"iconName\":\"arrow-right\", \"iconShown\":2,\"iconSize\":24} // 模版页面 模板页 .portal-containner { height: 100%; align-items: center; } 编辑模版 如果模版需要修改，那么点击对应列表的编辑按钮 删除模版 删除模版，那么点击对应列表的删除按钮。 此操作不可逆，请谨慎操作。 第二次确认删除弹框，如果删除则点击确定，反之则点击取消。 确定删除数据不能恢复！请谨慎。。。 "},"WorkSpace/Profile.html":{"url":"WorkSpace/Profile.html","title":"个人中心","keywords":"","body":"个人中心 用于修改用户名、密码和头像 进入个人中心 点击右上角的头像，选择个人中心。 修改用户名和头像 点击编辑，修改用户名后点保存 点击上方的+，选择图片可修改头像 修改密码 点击修改密码，依次输入原密码、修改后的密码，再次确认密码后点击确认。 "},"NoteBook/main.html":{"url":"NoteBook/main.html","title":"NoteBook","keywords":"","body":"NoteBook NoteBook是一个可以在浏览器中使用的交互式笔记本文档。它提供了一个集成的环境，允许用户在同一个文档中编写和运行代码、添加注释、文本说明和公式、插入图表和可视化结果，并实时查看代码执行的输出。 SNB的NoteBook主界面由单元格组成，主要包括code单元格、可视化组件单元格、数据处理组件单元格。此外SNB在NoteBook的交互体验、资源管理、交流分享及团队协作等方面做了很多关键的扩展。 功能概览 功能 解释 工具栏 工具栏提供对文件、Kernel和终端等的一系列扩展操作。详见工具栏 侧边栏 侧边栏为NoteBook提供一系列扩展功能。详见侧边栏 单元格（Cell） 编写、运行、分享代码或组件的最小单元，也是最核心的单元。详见单元格（Cell） Python单元格 编写、运行、分享Python代码。详见Python单元格 SQL单元格 编写、运行、分享SQL代码。详见SQL单元格 MarkDown单元格 编写、运行、分享MarkDown代码。详见Markdown单元格 EDA功能 EDA分析组件快速探索数据集特征的分布情况。详见EDA 可视化分析 帮助用户以交互方式处理和分析数据，创建丰富的可视化效果并可用于分享和展示。详见可视化分析组件 数据透视表 用可视化交互方式聚合和透视数据。详见数据透视表 评论 团队成员可以在单元格开展评论交流。详见评论 代码收藏 收藏代码存放在代码片段仓库。详见代码收藏 分享功能 分享单元格或整份NoteBook报告。详见分享 协作 当团队成员打开同一份NoteBook...详见实时协作 R支持 编写、运行、分享R代码。详见R语言支持 SageMath支持 编写、运行、分享SageMath代码。详见SageMath支持 Julia支持 编写、运行、分享Julia代码。详见Julia语言支持 环境状态栏 显示当前环境的状态信息，如镜像名称、镜像类型、CPU使用情况、内存使用情况等 快捷键 键盘快捷键支持。详见快捷键 相关操作 新建NoteBook WorkSpace管理界面下，点击左下角的新建 NoteBook按钮，弹出新页面。 依次输入标题、选择可用环境、Kernel类型并选择模式后点击提交： [!WARNING] NoteBook标题不能含有以下特殊字符：| / : * ? \" 目前支持的Kernel类型 Python R SageMath Julia [!NOTE] 即将支持更多的Kernel类型——如果您有需要优先支持的类型，可联系我们 feedback@smartnotebook.tech。 模式选择 Jupyter模式：经典的Jupyter模式，没有执行顺序的强制要求。在Kernel停止后，NoteBook状态不会被保存。 交互模式：交互模式（Reactive Mode），强制执行固定的自上而下的依赖顺序，即按照单元格在NoteBook中的排列顺序执行，当修改了一个单元格后，位于其下方的所有单元格将自动重新计算。 导入NoteBook WorkSpace管理界面下，点击左下角的新建NoteBook按钮右侧的小箭头，点击上传文件。 拖拽或点击从电脑选择上传支持的文件类型（.snb或.ipynb）。 支持导入的文件类型说明： snb文件： SNB导出的专用格式类型 ipynb文件：Jupyter NoteBook导出的文件类型 导入成功的NoteBook文件将和新建的NoteBook一起显示在您的NoteBooks文件列表。 修改NoteBook名称 方式一：在NoteBook列表页，鼠标移至名称一栏，点击编辑图标 对名称进行修改,最后点击√提交修改。 方式二：在NoteBook界面，双击顶部中间的标题进行修改，修改完成后鼠标移动到任意其他位置提交修改。 添加/删除Sheet 默认情况下，每个NoteBook的内容都可以显示在一个Sheet上，您可以在一个可滚动的页面上看到你所有的工作。但如果您的NoteBook非常大并且有大量数据，您可能需要将其内容组织到多个Sheet中。 在NoteBook文档左下角的+可以增加新的Sheet，方便用户组织NoteBook结构和内容。 多个Sheet共同组成一份NoteBook文档，当运行全部单元格或分享NoteBook时SNB会按Sheet的位置顺序依次执行和显示。 一个NoteBook中所有的Sheet共享相同的文件和资源，并且新创建的Sheet会继承先前Sheet的环境。 点击右侧的×可删除Sheet（一个NoteBook中至少存在一个Sheet，因此您无法删除NoteBook中所有的Sheet）。 [!WARNING] 注意删除Sheet的操作不可逆，已删除Sheet的内容无法恢复，请谨慎操作！ 返回WorkSpace 单击NoteBook左上角的LOGO可快速返回至WorkSpace管理界面。 --> 收藏NoteBook（置顶显示） 收藏后的NoteBook会在您的NoteBooks列表置顶显示，并显示收藏标记 以作区别。 方式一：在NoteBook界面点击标题右侧收藏标记收藏，提示您收藏成功（再次点击后取消收藏）。 方式二：在您的NoteBooks列表界面，点击...弹出操作菜单，点击收藏，提示您收藏成功（取消收藏亦然）。 "},"NoteBook/Cell.html":{"url":"NoteBook/Cell.html","title":"单元格（cell）","keywords":"","body":"单元格（cell）概述 单元格(Cell)是核心编写、运行和分享代码/组件的单元，支持交互式数据探索和展示结果。 多功能的单元格(Cell)适用于数据科学家、研究人员和程序员，促进逐步开发和测试代码，并即时查看输出。 交互性的单元格(Cell)使团队协作、教学和分享工作成果更便捷，以模块化方式组织代码简化复杂任务，单元格(Cell)提供灵活、交互式、可视化的环境，助力代码开发、数据探索和文档编写。 输入/输出区域 输入区域用于编写代码和使用组件 输出区域用来显示代码或一些组件运行的结果 单元格运行状态 未运行：执行按钮为小三角且左侧未显示行号 正在运行：执行按钮变为黑色正方形且旁边显示加载中的图标 此时点击黑色正方形执行按钮会强制中断单元格的执行。 已运行：执行按钮为小三角，按钮旁显示运行时长，单元格的左上方显示执行序号(execution_count) 选中状态 单元格（cell）的选中状态有两种： 编辑状态：单元格左侧显示绿色。此时焦点处于代码输入框中，输入框处于编辑状态。用于书写代码或配置低代码组件参数。 命令状态：单元格左侧显示蓝色。当前单元格处于选定状态，但焦点不位于输入框。用于单元格间的操作，比如利用快捷键快速插入新单元格。 选中状态的切换 当使用鼠标点击单元格输入框的代码编辑区域时，单元格的选中状态变为编辑状态，除此之外，当点击单元格的其他区域单元格的选中状态都为命令状态。 除使用鼠标点击来切换单元格的选中状态，也可以使用快捷键进行切换： Enter 回车：命令状态 --> 编辑状态 ESC 取消：编辑状态 --> 命令状态 [!Tip] 不同选中状态下有不同的快捷键。详见快捷键 单元格的类型 Code： Python：详见 Python单元格 SQL：详见 SQL单元格 MarkDown：详见 Markdown单元格 Data Display： Chart：详见 可视化组件 Table:详见 可视化组件 自助分析:详见 自助分析 EDA分析:详见 EDA组件 EDA概览:详见 EDA概览 Data Transform： 数据透视表:详见 数据透视表 Faas API： HelloAPI:详见 服务API 查询Demo:详见 服务API 预测Demo:详见 服务API Input： 下拉框：详见 下拉框 文本框:详见 文本框 标签页:详见 标签页 单选框:详见 单选框 时间日期:详见 时间日期 按钮:详见 按钮 ML/AI： 降为：详见 降为 聚类:详见 聚类 分类:详见 分类 回归:详见 回归 单元格的操作一览 通用操作 图标 操作 解释 备注 运行单元格 运行代码或低代码组件 输入输出显隐设置 配置分享NoteBook页面单元格输入和输出区域的隐藏/显示 下方新增单元格 在当前单元格下方新增默认类型为Python语言的单元格 Python代码类型 显示当前单元格的代码类型 点击可选择转换为其他代码单元格类型 删除当前单元格 删除当前单元格 AIGC功能 AI辅助生成/编辑/修复/解释代码 功能详见 数据智灵(AI伴侣) 更多操作 点击单元格（cell）右上角的 获取更多操作。 操作 解释 备注 向上插入单元格 在当前单元格上方新增默认类型为Python语言的单元格 命令状态下快捷键A 向下插入单元格 在当前单元格下方新增默认类型为Python语言的单元格 命令状态下快捷键B 清除输出 清除当前单元格的输出 剪切单元格 剪切当前单元格内容 命令状态下快捷键X 复制单元格 复制当前单元格内容 命令状态下快捷键C 粘贴单元格 内容粘贴至当前单元格 命令状态下快捷键V 上移一格 将当前单元格上移一格 下移一格 将当前单元格下移一格 Python学习助手 Python学习助手，可视化代码执行步骤 注册服务API（FASS) 将当前单元格内容注册为API服务 此功能详见 服务API 全屏显示 可将当前单元格全屏显示（专注模式） 命令状态下快捷键FF 拷贝出代码 拷贝出当前单元格的代码 该功能可以将低代码组件背后的代码拷贝出来，粘贴到 Python 单元格中运行，这个功能为用户提供了更多的自由度和灵活性。 悬浮按钮 图标 操作 解释 备注 评论 成员可对当前单元格评论 此功能详见 评论 收藏 可收藏当前单元格内容 此功能详见 代码收藏 分享单元格输出 分享当前单元格的输入内容，生成分享链接 此功能详见 分享 SQL单元格 图标 操作 解释 备注 SQL代码类型 显示当前单元格的代码类型 点击可选择转换为其他代码单元格类型 数据源 数据源 选择数据库或选用dfSQL 链式输入 链式输入 使用链式SQL功能时将前面链式输出的变量作为本单元格的输入 链式输出 链式输出 使用链式SQL功能时将本单元格输出的变量作为后续单元格的输入 结果保存为 结果保存为 将SQL或dfSQL的查询结果保存为新的变量 MarkDown单元格 图标 操作 解释 备注 MarkDown代码类型 显示当前单元格的代码类型 点击可选择转换为其他代码单元格类型 粗体 粗体 MarkDown单元格类型下 斜体 斜体 MarkDown单元格类型下 下划线 下划线 MarkDown单元格类型下 中划线 中划线 MarkDown单元格类型下 标记 标记 MarkDown单元格类型下 上角标 上角标2 MarkDown单元格类型下 有序列表 1. 第一项 2. 第二项 3. 第三项 4. 第四项 MarkDown单元格类型下 上传图片 MarkDown单元格类型下 代码 print(x) MarkDown单元格类型下 | 链接 | / | MarkDown单元格类型下 | --> 折叠/伸展单元格 input 折叠：折叠状态下只显示一行，或一行的高度内 input 伸展：恢复input的自适应显示高度 output 折叠：折叠状态下只显示一行，或一行的高度内 output 折叠：恢复output的自适应显示高度 全屏显示/退出全屏 点击单元格右上方的更多按钮，选择全屏显示，或在单元格为命令状态下按下快捷键FF ，可将当前单元格全屏显示。 在全屏模式下，可以正常执行或隐藏、转换单元格。点击右上角的切换按钮，可以将代码的输入输出框切换为双栏/单栏显示（双栏为水平布局、单栏为垂直布局） 点击右上角退出全屏将回到NoteBook文档页面 代码自动补全 引号补齐，包括单引号、双引号，英文半角下单双引号，' --> '' \"--> \"\" 三引号补齐，包括三单引号、三双引号，英文半角下三单双引号 \"\"\" ->\"\"\"\"\"\" ''' --> '''''' 文本选定，添加单双引号,选定文本输入单引号或双引号 ，文本添加双引号 单行或多行注释快捷键/取消注释快捷键，选中代码内容后按下Ctrl+/。 其他操作 添加单元格:鼠标移动至单元格的下边界处显示该菜单，点击在下方增加一个默认类型的单元格 更多类型：鼠标移动至单元格的下边界处显示该菜单，选择所需增加的单元格类型 Add Code Cell：点击在下方增加一个默认类型的单元格 常用快捷键 Ctrl+Enter：运行当前单元格 Shift+Enter：运行当前单元格,并选定下方单元格 Alt+Enter：运行当前单元格,并在下方插入一个 code 单元格 以下快捷键只有\"命令状态\" 才有效`： DD：删除当前单元格 A：在当前单元格前插入一个单元格 B：在当前单元格后插入一个单元格 C：复制当前单元格的全部内容 X：剪切当前单元格的全部内容 V：粘贴全部内容 [!Tip] NoteBook支持的全部快捷键详见 快捷键 魔法指令 内容待补充 通过魔法指令（magic commands）可以增强SmartNoteBook的功能和灵活性。 以下是常用的一些魔法指令： %run：运行 Python 脚本 %load：加载一个 Python 脚本 %time：测试一个语句或函数的执行时间 %matplotlib：集成 matplotlib 绘图库，实现 inline 绘图 %pwd：显示当前工作目录 %cd：更改当前工作目录 %ls：显示当前目录下的文件和目录 %who：显示当前命名空间中定义的变量 %reset：清空当前命名空间中定义的变量 %%timeit：测试一个语句或函数的平均执行时间 这些魔法指令只需要在NoteBook的代码单元格中输入，以百分号%或两个百分号%%开头即可。 %：行魔法指令。作用于单个代码行。它们可以在一行中直接插入，并影响该行的执行或提供一些附加功能。例如，\"%run\"是一个行魔法指令，用于运行外部的Python脚本文件。您可以在代码行前面加上\"%run\"，后跟要运行的脚本文件的路径，以执行该脚本文件。 %%：单元格(cell）魔法指令。作用于整个代码单元格。它们影响整个单元格中的代码执行，并提供更丰富的功能。例如，\"%%time\"是一个单元格魔法指令，用于测量整个代码单元格的执行时间。通过在代码单元格的开头使用\"%%time\"，您可以轻松获得代码块的执行时间，以进行性能分析。 在输入魔法指令时，可以使用?查看更多帮助信息。例如，输入%run? 可以查看%run魔法指令的详细用法。 更多的魔法指令可以参考Useful Magic Commands "},"NoteBook/Python.html":{"url":"NoteBook/Python.html","title":"Python单元格","keywords":"","body":"Python单元格 用户可以在Python单元格中编写和执行任何有效的Python代码。 创建Python单元格 创建Python单元格有以下几种方式： 方式一：单击单元格右上角的 + 号 方式二：鼠标移动到单元格的下边界，单击悬浮框的菜单添加单元格 方式三：鼠标移动至代码块的下边界，当显示悬浮操作框时，单击更多类型，然后选择Python。 方式四：在单元格右上角的更多...操作里选择在上方插入单元格或在下方插入单元格，也可以创建Python单元格 方式五：当单元格处于命令状态下，可使用以下快捷键创建： A：在当前单元格前插入单元格 B：在当前单元格后插入单元格 运行Python单元格 编写Python代码 点击Cell左上角的运行按钮 开始执行代码，运行完毕后按钮右侧将显示运行时长 结果输出 折叠/展开输入框 行号（运行前为空，运行后显示行号） 折叠/展开结果输出 当代码运行报错时，报错信息会以红色底显示输出： 关于显式/隐式打印 在NoteBook中，显式打印和隐式打印是在输出结果时的两种不同方法。 \"显式打印\"：是指使用print()函数直接打印出你想要查看的内容。例如，print(\"Hello, World!\")会在屏幕上打印出\"Hello, World!\" \"隐式打印\"：是指在交互式环境中，仅输入变量名或表达式，Python会自动显示其结果。例如，如果你有一个变量x = 5，在新的一行只输入x，输出区域会显示结果5。 任何显式打印（如：print)的值都将显示在输出中，如： 隐式打印值的行只有在出现在单元格的最后一行时才会显示在输出中，如： 如果单元格中没有显式打印语句，并且最后一行也未显式或隐式打印任何值，此时该单元格不会将任何内容显示为输出。这类情况完全没有问题，这种通常是为了保持内容的可读性，为另外的单元格提供包、函数或数据的支持。比如： 单元格类型转换 您可以点击单元格右上角将单元格从Python 转换为SQL或Markdown单元格，反之亦然。 "},"NoteBook/SQL.html":{"url":"NoteBook/SQL.html","title":"SQL单元格","keywords":"","body":"SQL单元格 SNB通过SQL单元格提供对SQL的一流支持，每个单元格都是一个成熟的SQL集成开发环境，例如可以选择数据源、代码自动补全、执行SQL查询和保存查询结果等。 每个NoteBook中可以添加无限数量的SQL单元格，它们与文本、代码、图表以及各类数据分析组件交错，从而为用户提供了一个非常灵活的数据分析环境。 --> SQL单元格的特性/要点 SNB在SQL应用方面进行了深入的优化和支持，使得SQL数据查询和处理变的非常便捷和高效。 区别于您之前所使用的“常规”SQL查询工具，使用SNB操作SQL有以下几个特性/要点： DBSQL和dfSQL。在SNB中有两种SQL查询方式：DBSQL允许用户通过连接远程数据库或数据仓库运行SQL查询。dfSQL允许用户以SQL语法对DataFrame变量进行查询、变换、统计和过滤等操作。两种查询方式相融合，可以帮助用户编写和执行一些非常强大的数据处理流程。 查询结果自动存储为DataFrame变量。DBSQL查询的结果均可以作为DataFrame变量返回，后续可以采用Python代码或dfSQL继续进行数据分析或数据建模。。 用户可以通过dfSQL直接读取csv文件，后续进行统计汇总等分析。 动态SQL：SQL单元格支持Jinja2表达式模板，用户可以在SQL代码中引用Python变量，并且使用流程控制（if...else.../for循环等等），极大程度上扩展了SQL语言的灵活性。 链式SQL：可以将复杂的嵌套查询转化为简单的链式CTE（Common Table Expression）查询SQL，使代码更加简洁、易于调试、复用及高效。 何时使用DBSQL VS dfSQL？ 很简单，看您的数据存储在哪里或者说看您查询的对象类型是什么： 当您需要查询远程数据库或数据仓库时使用DBSQL 当您查询的对象是DataFrame变量或csv文件，则选用dfSQL 以下我们整理了一张表格来区别二者的适用场景： 目标用途 DBSQL dfSQL 查询远程SQL数据库 √ × 使用数据库特定的功能 √ × 查询Pandas DataFrame × √ 以DataFrame返回结果 √ √ 连接来自不同数据源的数据集 × √ 适合查询超大数据集 √ × 查询中小数据集的速度 快 极快 通过组合DBSQL和dfSQL，用户能以更流畅的方式构建复杂的数据处理流程。 我们举两个例子来说明： 通过DBSQL从远程数据库中获取数据，此时数据从远程数据库表中拷贝至用户定义的DataFrame变量中，然后我们使用Python代码对某一列进行地理信息编码（明显相比SQL，Python更擅长此类操作）。接下来我们如果需要对数据进行分组和排序，可以继续选择使用SQL语言对DataFrame进行处理（dfSQL的功能）。 当我们用到不同的数据源，并且需要将数据进行关联查询：比如我们从MySQL通过DBSQL获取数据集dfA，从Oracle通过DBSQL获取数据集dfB，此时，我们可以选择使用dfSQL将两个数据集开展关联查询（依然使用SQL的方式。当然，您如果对Pandas熟悉也可以使用Python代码的方式进行关联）。 创建SQL单元格 方式一：首先点击单元格右上角 + 号或单元格下方Add Code Cell，新建一个默认的代码单元格，然后点击右上角的转换类型，选择转换为SQL。 方式二：鼠标移动至单元格的下方，当显示悬浮操作框时，单击更多类型，然后选择SQL。 相关操作 1. DBSQL查询 步骤： 新建SQL单元格 在数据源下拉框中选择DB数据源（连接DB数据源的操作详见数据源） 在结果保存为处填写输出变量名（SNB会默认分配一个变量名，如df1 、df2等） 编写SQL代码 执行单元格 经以上几步我们执行了一个DBSQL查询，并将结果保存在DataFrame变量。 2. dfSQL查询 步骤： 新建SQL单元格 在数据源下拉框中选择dfSQL 在结果保存为处填写输出变量名（SNB会默认分配一个变量名，如df1 、df2等） 编写SQL代码(表名为已存在的DataFrame变量名称) 执行单元格 这样我们就执行了一个dfSQL查询，使用SQL的方式操作DataFrame变量，并将结果保存在新的DataFrame变量。 dfSQL还可用于读取csv文件 像这样： select * from '/home/Iris.csv' 或者这样： select Id, SepalLengthCm, SepalWidthCm, PetalLengthCm, PetalWidthCm,Species from '/home/Iris.csv' [!Tip] dfSQL查询必须使用DuckDB的PostgreSQL风格SQL编写，它不兼容某些特定于数据库的函数。关于dfSQL支持的内容可参考DuckDB Documentation。 3. 动态SQL查询 通过使用Jinja2表达式模板，用户能够在SQL单元格中引用Python变量，并且使用if...else.../for等关键字对SQL语句进行流程控制。 格式如下： 变量引用： 引用Python变量：a = 100 {{a}} 引用字典： data ={\"a\":100,\"b\":200} {{data.a}} {{data.b}} if else 判断： {% if b >0 %} ,{{a}} {% endif %} for 循环： {% for i in list_1 %} , {{i}} {% endfor %} [!Tip] 关于动态SQL支持的更多内容可以参考Jinja2 模板。 动态SQL例子 例1：变量引用 我们在Python单元格中定义并运行两个变量： Population = 500 HouseAge = 30 在SQL单元格中引用两个变量作为where条件： select * from df2 where Population > '' and HouseAge 例2：if..else..： 延续例1： 我们先来统计符合条件的房子数量，赋给house_count变量： 按照估价（target）从低到高排序取前5条；如果不存在，返回“符合条件的房子不存在！” select '符合条件的房子不存在！'; 例3：for循环： 我们使用Python代码将我们需要的信息字段放入list变量： columns = ['HouseAge', 'Population', 'target'] 然后把查询日期和需要的字段信息放到SQL语句： select '2023-01-01' from df2 4. 链式SQL查询 链式SQL用于将复杂的查询分解为易于阅读、理解和调试的原子单元，每个单元都可以分别运行、编辑、缓存和调试。 步骤： 新建SQL单元格 在数据源下拉框中选择DB数据源（连接DB数据源的操作详见数据源） 在结果保存为处填写输出变量名（SNB会默认分配一个变量名，如df1 、df2等） 根据输入输出逻辑勾选链式输入、链式输出 编写SQL代码 执行单元格 链式SQL例子 为方便理解链式SQL的原理和过程，我们可以将SNB的DEBUG功能打开（查看每一步的SQL语句）： 步骤① ： 步骤②： 步骤③： [!TIP] 我们在变量预览中能够查看链式SQL执行过程中产生的变量、变量类型和变量的值来清晰的感知整个过程： 注释 在SNB中，SQL注释用## 双井号开始，末尾用分号;结束： 支持T-SQL和PL/SQL T-SQL是Transact-Structured Query Language的缩写，是微软公司用于SQL Server数据库管理系统的扩展版本。它基于ANSI SQL标准，提供了更多的扩展和特性，如存储过程、触发器、表变量和用户定义函数等。使用T-SQL语言可以对数据库中的数据进行查询、更新、插入和删除操作。T-SQL还可以用来创建、修改和管理数据库对象，如表、视图、索引等。 PL/SQL全称为Procedural Language/SQL，是Oracle公司用于其Oracle数据库管理系统的一种专用编程语言。PL/SQL是一种基于SQL语言的高级编程语言。它具有结构化编程能力，支持面向过程编程，包括循环、条件语句、变量、常量、过程和函数等。 使用T-SQL 当我们连接好了SQL Sever的数据源，在执行T-SQL代码时可能会遇到报错或输出提示非标准的DDL语句，此时我们可以通过以下步骤来实现支持所有的T-SQL代码： 添加Python单元格 侧边栏的数据资源下复制所用SQL Sever数据源的连接信息 将连接信息复制到Python单元格里 在连接信息下方增加T-SQL语句和执行代码： # 数据源的连接信息 from snb_plugin.sql.execute_sql import __smartnotebook_getengine_by_conn_id as snb_conn engine=snb_conn(\"0242ac110004-11ed7b8d-9d8364a0-81eb\", context=globals()) # T-SQL语句 SQL=\"\"\" DECLARE @Number INT; SET @Number = 100; IF @Number > 100 PRINT 'The number is large.'; ELSE BEGIN IF @Number 使用PL/SQL 与执行T-SQL代码类似的，当我们连接好了Oracle的数据源，在执行PL/SQL代码时可能会遇到报错或输出提示非标准的DDL语句，此时我们可以通过以下步骤来实现支持所有的PL/SQL代码： 添加Python单元格 侧边栏的数据资源下复制所用Oracle数据源的连接信息 将连接信息复制到Python单元格里 在连接信息下方增加PL/SQL语句和执行代码： # 数据源的连接信息 from snb_plugin.sql.execute_sql import __smartnotebook_getengine_by_conn_id as snb_conn engine=snb_conn(\"0242ac110004-11ed7c2a-8a556732-8e72\", context=globals()) # PLSQL语句 SQL = \"\"\" declare i number(2) := 12 ; s varchar2(10) := 'end' ; begin IF i 10 THEN dbms_output.put_line('大于10'); ELSE dbms_output.put_line('等于10'); END IF; dbms_output.put_line(s); end; \"\"\" # 执行PLSQL语句 conn = engine.raw_connection() with conn.cursor() as cursor: cursor.execute(SQL) conn.commit() "},"NoteBook/Markdown.html":{"url":"NoteBook/Markdown.html","title":"MarkDown单元格","keywords":"","body":"MarkDown单元格 MarkDown单元格为我们提供了一个熟悉的、所见即所得的MarkDown编辑器环境。 Markdown单元格允许用户编写纯文本并使用Markdown语法规则设置格式。此外还支持标准的LaTex数学公式和符号，因此可以非常方便的在文本中插入数学符号。 Markdown单元格通常用作代码的解释性或描述性文本，此外SmartNoteBook还会根据MarkDown的标题结构和层级帮助我们自动生成大纲目录，方便我们快速掌握文档结构。 创建MarkDown 创建MarkDown的两种方法： 鼠标移动到单元格的下方，当显示悬浮操作框时，单击更多类型，然后选择MarkDown。 直接单击单元格右上角的 + 号或者单元格下方的Add Code Cell，然后点击右上角的，选择Convert to Markdown。 MarkDown的操作 编写MarkDown 如果熟悉MarkDown的语法规则，您可以直接在编辑框中书写MarkDown代码；如果不太熟悉，也可以借助上方的快捷工具栏来辅助您调整格式、上传图片以及嵌入链接等。下方会提到几个例子帮您熟悉MarkDown的语法。 执行单元格 MarkDown编写完成后无需执行，将鼠标移动至单元格以外即可保存和显示。 添加标题 Markdown中的标题有六个等级，分别是从一级到六级。 我们通过在标题名字前面加井号#，一个#表示一级标题、两个#号表示二级标记，依次类推，六个#号表示六级标题。其中一级标题字体最大，六级标题字体最小，各等级标题的渲染效果如下： Markdown HTML 渲染输出 # 一级标题 一级标题 一级标题 ## 二级标题 二级标题 二级标题 ### 三级标题 三级标题 三级标题 #### 四级标题 四级标题 四级标题 ##### 五级标题 五级标题 五级标题 ###### 六级标题 六级标题 六级标题 添加列表 要在MarkDown中创建无序列表，请使用*或-符号。要创建有序列表，请使用前面跟有数字的)或.符号。（注意：符号后需跟一个空格后再输入列表内容） 添加链接 要添加指向网站的链接，您可以将文本括在方括号[]中，后跟用括号()括起来的URL。 插入代码 您可以通过将文本换行在反引号中来突出显示文本中的变量，也可以在文本前后使用3个反引号来创建单元格。 插入引用 要创建块引用，请使用>符号加一个空格然后跟文本内容： 插入图片 直接复制粘贴图片即可将图片插入MarkDown单元格。 当然，也可以采用MarkDown单元格提供的快捷工具栏： 插入LaTeX数学公式 行内公式 $x=1$ 与文字混排 行间公式 $$ x=1 $$ 独立成行 语法和样例可参考LaTex中文手册。 更多Markdown 语法 更多Markdown 语法可参考此Markdown基本语法。 动态MarkDown（高级用法） SmartNoteBook的Markdown单元格支持使用Jinja模板语言将变量与文本混合。 比如你可以将Python变量直接插入Markdown单元格中： 像平时一样在MarkDown单元格中写入文本，然后将变量括在两个大括号中，按下Ctrl+Enter执行。参考下图的例子： 另外，我们也可以利用Jinja模板语言的流程控制配合Python变量或HTML标记实现或简化一些操作： 例如： 实现循环换行 实现if...else判断 实现for循环 [!Tip] 如果您想要在MarkDown单元格中输出显示双左大括号 `{{ ` 或双右大括号 `}}` ，需采用这种方式：{{  '{{'  }} → {{ ， {{  '}}'  }} → }}。 设置MarkDown的标签样式（高级用法） MarkDown的呈现需要解析成HTML, 其支持的HTML标记也只是一部分。从这个角度上讲，Markdown是HTML的一个简化标记形式的子集，因此我们也可以利用CSS定义来重新对Markdown的标签样式进行定义。 例如： /**一级标题**/ .v-note-show h1 { font-family:\"方正小标宋GBK\"; font-size: 22pt; text-align:center; color:black; font-weight:bold; line-height:150%; } /**二级标题**/ .v-note-show h2 { font-family:\"黑体\"; font-size: 16pt; color:black; } /**三级标题**/ .v-note-show h3 { font-family:\"楷体\"; font-size: 16pt; font-weight:bold; } /**四级标题**/ .v-note-show h4 { font-family:\"仿宋\"; font-size: 16pt; font-weight:bold; } /**五级标题**/ .v-note-show h5 { font-family:\"仿宋\"; font-size: 16pt; font-weight:normal; } /**正文段落**/ .v-note-show p { font-family:\"仿宋_GB2312\"; font-size: 16pt; font-weight:normal; line-height:37.3px; text-indent:32pt; } /**正文加粗强调**/ .v-note-show strong { font-family:\"仿宋_GB2312\"; font-size: 16pt; font-weight:bold; line-height:37.3px; } /**无序列表**/ .v-note-show ul li{ font-family:\"仿宋_GB2312\"; font-size: 16pt; font-weight:normal; line-height:37.3px; } /**有序列表**/ .v-note-show ol li{ font-family:\"仿宋_GB2312\"; font-size: 16pt; font-weight:normal; line-height:37.3px; } /**自定义**/ #md_title{ text-align:center; font-weight:bold; font-size: 5pt; } 单元格类型转换 您可以点击单元格右上角将单元格从Markdown转换为Python或SQL单元格，反之亦然。 MarkDown快捷键操作 MarkDown操作的快捷键详见快捷键 "},"NoteBook/EDA.html":{"url":"NoteBook/EDA.html","title":"探索性分析(EDA)组件","keywords":"","body":"EDA组件 EDA 是 Exploratory Data Analysis（探索性数据分析）的缩写。 EDA 是数据分析过程中的一项重要任务，旨在通过可视化和统计方法来理解数据集的特征、结构和关系，揭示数据中的模式、异常和潜在关联。通过对数据进行探索性分析，可以获取关于数据集的初步认识，为后续的建模、假设检验和预测建立基础。 EDA 通常涉及以下任务： 数据质量检查：检查数据集中是否存在缺失值、异常值或错误数据，并进行处理。 描述性统计分析：计算数据集的基本统计指标（如均值、中位数、标准差等）以及数据的分布情况。 数据可视化：使用图表、图形和图像等可视化工具展示数据的特征，以发现模式、趋势、异常值等。 相关性分析：探索数据变量之间的关系，通过计算相关系数或绘制散点图等方法来了解变量之间的相关性。 特征工程：识别和构造合适的特征，以提高后续分析或建模的效果。 EDA分析组件 EDA分析组件提供了一个直观的可定制界面，用于探索数据集内不同特征的数据点之间的关系。使用EDA分析组件，您可以根据每个数据点的特征值来控制它的位置、颜色和视觉效果。 创建EDA分析组件 鼠标移动至单元格的下边界，当显示悬浮操作框时，单击更多类型，然后选择EDA分析。 基本操作 为学习EDA分析组件的基本操作，我们用一个简单的操作案例来体验。 例：通过EDA分析组件从不同维度探索泰坦尼克船上人员的分布情况： 可以看到EDA组件有三个主体区域 顶部 —— 控制工具栏 中间 —— 主可视化区域 右侧 —— 数据点信息面板 EDA分析组件基本的操作流程如下： 0.创建EDA分析单元格 1.下拉选择您要探索的DataFrame 2.点击运行 3.使用控制工具栏中的控件来驱动探索 4.观察主可视化区域的分析结果 5.点击数据点，右侧信息面板显示详细信息 单变量分析 这里我们将分别地查看目标变量，即 Survived（是否生还） 和其它的分类特征如sex（性别）、Pclass（船舱等级）、（age）年龄分箱等。当然，你也可以看看其它特征。 推论： 数据集中的女性生还人数比例较高 一等舱和二等舱相比三等舱生还人数比例较高 0-10岁儿童的生还比例较高 双变量分析 我们再来找找目标变量和分类自变量（Survived）之间的关系。 推论： 女性生还希望更大 乘坐一等舱的生还希望更大 从年龄来看没有太明显的分别，相比较而言0-10岁儿童生还希望较大 EDA概览 对于一个数据分析师来说，项目开始的第一步总是数据探索性分析(EDA)。但我们知道EDA通常都很繁琐和无趣，而EDA概览组件能够轻松生成一份数据分析报告。 这份报告中包含常用的数据分析指标：例如数据的形状、缺失值、各个变量的分布及变量之间的相关性等指标，以一种非常直观的形式反映数据的健康程度，为数据分析师提供大量的时间用于特征工程和建模。 创建EDA概览 鼠标移动至单元格的下边界，当显示悬浮操作框时，单击更多类型，然后选择EDA概览。 基本操作 0.创建EDA概览单元格 1.下拉选择您要探索的DataFrame 2.点击运行 3.查看EDA分析报告 数据分析报告中总共包含六部分：分别是概要、各个变量的详细信息、变量交互、相关性、缺失值、样本。 概要（Overview） 概要提供对数据集的静态描述：包含特征、数据、缺失值、重复行的数量和占比，总数据及平均每条数据所占用内存的大小，变量的数据类型等信息。 Alerts 展示数据的警示信息。包含重复行占比、哪些变量具有很高的相关性、数据是否均匀分布等信息。 变量信息（Variables） 变量信息集成了pandas 的 info、describe 等基础功能，提供了友好的界面，对每一个变量进行详细的统计，为数据分析师减轻了不少工作量。 变量信息能够统计数据集中所有的变量共有多少个不同的值以及占总数据量的比例，缺失值、无穷、均值、最小最大值、0的个数、每个特征占的内存大小。 More details 按钮能够切换详细信息，提供了变量的分数位统计信息、直方图、每个值出现的次数、极端值出现的次数等信息。 变量交互（Interactions） 变量交互可以绘制变量之间的散点图或者其它图像，可以直观分析变量间的相关性。 相关性（Correlations） 相关性通过绘制热力系数图，直观反映变量之间的相关性，集成了pandas 的 corr 和 sns 的heatmap功能，提供了各个方法的计算原理。 Table 用来显示变量之间的相关性系数。 缺失值（Missing values） 缺失值：用图形的方式直观的反映哪些变量含有缺失值，以及缺失值之间的关系。 样本（Sample） 展示前十行和后十行的样本 "},"NoteBook/DataTransform.html":{"url":"NoteBook/DataTransform.html","title":"数据处理组件","keywords":"","body":"数据透视表 数据透视表组件允许用户以零代码可视化的方式快速汇总和分析大量数据。使用数据透视表可以按照数据的不同字段从多个角度进行透视，查看数据不同层面的汇总信息、分析结果以及摘要数据。 使用数据透视表可以深入分析数值数据，以帮助用户发现关键数据，并作出有关企业中关键数据的决策。 数据透视表将DataFrame作为输入，根据您的配置对其进行聚合，并返回输出一个DataFrame的数据对象，该数据对象可以在应用中预览和显示或在NoteBook后续单元格中使用。 创建数据透视表组件 鼠标移动至代码块的下边界，当显示悬浮操作框时，单击更多类型，然后选择数据透视表： 基本操作 从左上角DataFrame数据源下拉框中选择需要转换的df，其所有列名将显示在左侧的字段选择列表中 将字段从选取列表中拖动到对应的配置中 行：作为聚合依据的字段，垂直呈现 列：作为聚合依据的字段，水平呈现 值：选择需要聚合和计算的字段，并设置计算方式 完成配置后，点击左上角的运行单元格，右侧区域可预览处理后的数据对象（如需修改输出的df变量名称，可在运行前进行修改） [!Tip] 如要聚合的DataFrame包含字段过多，可以利用左侧的过滤字段去模糊搜索匹配所需字段后再拖入右侧的配置区域。 例子 按销售日期和商品类别统计销售额： 数据透视表的原理 可参考Pandas中关于pivot_table的解释: "},"NoteBook/Visualization.html":{"url":"NoteBook/Visualization.html","title":"可视化组件","keywords":"","body":"可视化组件 Chart组件 Chart组件帮助用户以可视化交互方式浏览和处理数据，无需编写代码即可创建丰富的图表用于展示和分享。 利用Chart组件我们可以构建以下图表： --> Chart组件支持的图标类型包括： 标准Chart类型: 如柱状 图（bar）、折线图（line）、散点图（point）、面积图（area） 组合图表：如Grid组合、overlap等（开发中） 其他图表：如地图、箱线图（盒须图）、词云图（WordCloud）、漏斗图等（开发中） 创建Chart 鼠标移动至单元格的下边界，当显示悬浮操作框时，单击更多类型，然后选择Chart。 基础操作 为了学习Chart的基本操作，我们创建一个简单的柱状图，分析泰坦尼克数据中亲戚个数与生还数量的情况。 通过上面例子，Chart组件大致操作流程如下： 选择要分析的DataFrame 输入标题（可选）、选择图表类型并配置图表参数 选择X、Y轴字段并设置聚合函数、字段类型和格式等 设置多系列和排序方式 运行单元格 以下我们对Chart的一些功能点做简要介绍： 图表类型参数 柱状图 配置项 作用 取值 备注 标签 开关项：设置数据系列中是否显示标签 开启/关闭 默认：开启 堆叠 开关项：设置数据系列中是否堆叠显示 开启/关闭 默认：关闭 折线图 配置项 作用 取值 备注 标记 开关项：设置数据系列中的数据点是否显示圆点标记 开启/关闭 默认：开启 标签 开关项：设置数据系列中是否显示标签 开启/关闭 默认：开启 平滑 开关项：设置折线是否平滑 开启/关闭 默认：开启 填充 设置是否填充折线下方区域 开启/关闭 默认：关闭 散点图 配置项 作用 取值 备注 标签 开关项：设置数据系列中是否显示标签 开启/关闭 默认：开启 形状 设置散点的形状 圆/正方形/菱形/三角形/上三角/下三角/右三角/左三角/楔子/十字 默认：圆 大小 设置散点大小 正整数 默认：120 面积图 配置项 作用 取值 备注 标记 开关项：设置数据系列中的数据点是否显示圆点标记 开启/关闭 默认：开启 标签 开关项：设置数据系列中是否显示标签 开启/关闭 默认：开启 平滑 开关项：设置折线是否平滑 开启/关闭 默认：开启 X/Y 轴字段选择 字段选择列表左边显示字段名称，右侧显示系统默认识别的字段类型。 更改字段类型 支持以下字段类型： 数值型 (Numeric)： 描述：这种类型的字段用于存储数字，这些数字可以是整数或小数。 用途：用于存储需要进行数学计算的数据，例如价格、数量、分数、百分比等。 例子：商品的价格为100.50元，这个100.50就是数值型数据。 枚举型 (Enumeration)： 描述：枚举型字段由一组预定义的值组成，通常用于表示一组固定的选项或类别。 用途：用于限制某个字段的值只能选择预定义的几个选项。 例子：订单状态可以是“未支付”、“已支付”、“已发货”、“已完成”等，这些状态就可以定义为枚举型数据。 序列型 (Sequential)： 描述：序列型字段表示按照某种规律或顺序生成的数据序列。 用途：常用于生成唯一的标识符，如订单编号、用户ID等。 例子：每当有新订单时，订单编号可能会按照某种规律递增，如从001到002再到003，这样的编号就是序列型数据。 时间型 (Datetime)： 描述：时间型字段用于存储日期和/或时间信息。 用途：记录事件发生的日期和时间，如订单的下单时间、用户的注册日期等。 例子：2023-08-07 15:30:00 表示某个事件在2023年8月7日的下午3点30分发生，这就是一个时间型数据。 不同的数据类型下可以设定相应的格式显示，更改数据类型将影响数据的处理和呈现方式。 聚合数据 支持对行/列数据使用以下聚合函数： 计数 (Count) 描述：计算特定字段中的项目数量。 示例：如果我们有一个订单列表，计数函数可以告诉我们共有多少个订单。 求和 (Sum) 描述：将特定字段中的所有数字加起来。 示例：在销售数据中，求和函数可以用来计算所有订单的总销售额。 平均值 (Average) 描述：计算特定字段中所有数字的平均值。 示例：在学生成绩列表中，平均值函数可以告诉我们学生的平均分数是多少。 中位数 (Median) 描述：找到特定字段中所有数字的中间值。当数字按升序排列时，中位数是位于中间的数字。 示例：在一个包含员工工资的列表中，中位数函数可以告诉我们中间员工的工资是多少，这有助于识别工资分布。 最小值 (Min) 描述：确定特定字段中的最小数字。 示例：在商品销售价格列表中，最小值函数可以告诉我们哪个商品的价格最低。 最大值 (Max) 描述：确定特定字段中的最大数字。 示例：在一组记录跑步时间的数据中，最大值函数可以告诉我们最慢的跑步时间是多少。 标准差 (Standard Deviation) 描述：衡量数据点偏离平均值的程度。高标准差意味着数据点离平均值差距较大，而低标准差意味着数据点接近平均值。 示例：在学生成绩数据中，标准差可以告诉我们学生成绩的分散程度或稳定性。 方差 (Variance) 描述：衡量数据点偏离其平均值的程度的平方。它是标准差的平方。 示例：在股票价格数据中，方差可以帮助我们了解价格的波动程度。 这些聚合函数为数据分析提供了强大的工具，使我们能够从大量数据中提取有意义的信息和洞察。 添加系列 当需要在一张图表上绘制多列，如果数据满足不同类型的标签共享相同的度量单位，此时可以通过添加系列来实现。这不仅使你能够在同一张图表上比较不同数据系列的趋势，而且还可以更直观地看到它们之间的关系。例如： 注意事项： 当你在图表上添加多个系列时，确保它们的度量单位是相同的，这样才能确保数据的比较是有意义的。 为了避免混淆，系统会自动为每个系列选择一个独特且与其他系列区分开的颜色。 如果图表中有太多的系列，可能会使图表变得混乱且难以解读。在这种情况下，考虑是否可以将一些系列合并，或者使用不同的图表类型，如堆叠柱状图。 分箱 通常使用\"分箱\"（也称为\"分桶\"）将一系列的数据值划分为几个不同的范围或类别。 如何使用系列分箱功能： 开启分箱开关 选择分箱方法：开启分箱功能后，您将有两种分箱方法可供选择： 等宽法：这种方法会将整个数据范围分为具有相同宽度的“箱子”或区间。例如，如果数据范围是0-100，您选择了5个箱子，那么数据会被分为0-20, 20-40, 40-60, 60-80, 80-100这五个区间。 等频法：这种方法会根据数据的分布，确保每个“箱子”里有大致相同数量的数据点。例如，对于一组有100个数据点的数据，如果您选择了5个箱子，那么每个箱子里都会有大约20个数据点。 选择分箱数量：确定了分箱方法后，您还需要指定要创建的“箱子”或区间的数量。输入合适的数字，系统将根据您的选择自动为数据进行分箱。 排序 Chart提供了多种用于对数据排序的选项： 图表设置 点击Chart组件左下角的设置按钮 可以看到一些图表的设置选项。 宽度/高度 允许用户自定义Chart的宽度和高度，宽度和高度值都应该是以像素（px）为单位的整数。 主题设置 设置图表的主题样式： dark: 为深色背景设计的主题，具有亮色的文本和元素，以确保对比度和可读性。 excel: 仿照 Microsoft Excel 默认图表的样式设计。 fivethirtyeight: 受到 FiveThirtyEight 数据新闻网站的图表样式启发。 ggplot2: 模仿 R 语言的 ggplot2 包的默认样式。 googlecharts: 受到 Google Charts 工具的样式启发。 latimes: 受到《洛杉矶时报》的数据可视化风格启发，提供了一种在报纸的数字出版物中常见的清晰和专业的外观。 powerbi: 仿照 Microsoft Power BI 的默认图表样式。 quartz: 受到 Quartz 新闻网站图表样式的启发。 urbaninstitute: 受到 Urban Institute 的数据可视化风格启发。 VOX: 受到 Vox 新闻网站的图表样式启发。 图例 允许用户通过开关项配置图例的显隐。 隐藏/显示配置 允许用户根据需要显示或隐藏图表的配置区域。当配置区域被隐藏时，图表的图形区域将被最大化显示，使得图表更为清晰并占据更多的屏幕空间。 代码拷贝 允许用户直接从Chart组件中复制图表的代码，并将其粘贴到Python单元格中。用户可以在Python环境中更加灵活地自定义和修改图表。 Chart开放API Chart API 为您提供了一个以编程方式自定义显示图表的方式。 样例 河流图themeRiver from snb_plugin.snbcharts.SnbCharts import themeRiver themeRiver(df, date, series, value, title='', height='550px', width='960px') 接口说明： df：数据集，类型：pandas.DataFrame date：日期参数，格式为字符串类型'2022-07-09' series：按照选定的维度进行展现 value：统计数据，选择需展现的数值 title：图表的标题 height：高度，格式：px 或百分比 width：宽度，格式：px或百分比 样例： from snb_plugin.snbcharts.SnbCharts import themeRiver themeRiver(temp,'day','project','count_day',height='550px', width='960px') 散点图scatterChart from snb_plugin.snbcharts.SnbCharts import scatterChart scatterChart(df, x_col, y_col, size_col, series=None, title='', height='550px', width='960px') 接口说明： df：数据集，类型：pandas.DataFrame x_col：x轴显示列 y_col：y轴显示列 size_col：统计数据，选择需展现的数值 series：按照选定的维度进行展现 title：图表名称 height：高度，格式：px 或百分比 width：宽度，格式：px或百分比 样例： from snb_plugin.snbcharts.SnbCharts import scatterChart scatterChart(df,'hour','week_cn','count_hour',series=None, title='SmartNotebook', height='550px', width='960px') 散点图极坐标scatterPolarChart from snb_plugin.snbcharts.SnbCharts import scatterPolarChart scatterPolarChart(df, x_col, y_col, size_col, series=None, title='', height='550px', width='960px') 接口说明： df：数据集，类型：pandas.DataFrame x_col：x轴显示列 y_col：y轴显示列 size_col：统计数据，选择需展现的数值 series：按照选定的维度进行展现 title：图表名称 height：高度，格式：px 或百分比 width：宽度，格式：px或百分比 样例： from snb_plugin.snbcharts.SnbCharts import scatterPolarChart scatterPolarChart(df,'hour','week_cn','count_hour',series=None, title='SmartNotebook', height='550px', width='960px') 热力图 heatmapChart from snb_plugin.snbcharts.SnbCharts import heatmapChart heatmapChart(df, x_col, y_col, size_col, title='', height='550px', width='960px') 接口说明： df：数据集，类型：pandas.DataFrame x_col：x轴显示列 y_col：y轴显示列 size_col：统计数据，选择需展现的数值 title：图表名称 height：高度，格式：px 或百分比 width：宽度，格式：px或百分比 样例： from snb_plugin.snbcharts.SnbCharts import heatmapChart heatmapChart(df,'hour','week_cn','count_hour', title='SmartNotebook', height='550px', width='960px') 雷达图radarChart from snb_plugin.snbcharts.SnbCharts import radarChart radarChart(df, column, series, value, title='', height='550px', width='960px') 接口说明： df：数据集，类型：pandas.DataFrame column：显示列 series：按照选定的维度进行展现 value：统计数据，选择需展现的数值 title：图表名称 height：高度，格式：px 或百分比 width：宽度，格式：px或百分比 样例： from snb_plugin.snbcharts.SnbCharts import radarChart radarChart(df, \"hour\", \"week_cn\", \"count_week_cn\", title='SmartNotebook', height='550px', width='1600px') 盒须图boxPlot from snb_plugin.snbcharts.SnbCharts import boxPlot boxPlot(df, series, value, title='', height='550px', width='960px') 接口说明： df：数据集，类型：pandas.DataFrame series：按照选定的维度进行展现 value：统计数据，选择需展现的数值 title：图表名称 height：高度，格式：px 或百分比 width：宽度，格式：px或百分比 样例： from snb_plugin.snbcharts.SnbCharts import boxPlot boxPlot(df, 'Province', 'per_gdp', title='SmartNotebook', height='550px', width='980px') 桑基图(Sankey Diagram) Sankey Diagram，用来展示数据的“流动”变化。 左右两侧的矩形叫做“节点”，代表了不同的对象 节点与节点之间的流线叫做“边”，代表数据的流动 边的粗细与流量（流动数据的具体数值叫做“流量”）成比例，流量越大，边的线条越粗。 from snb_plugin.snbcharts.SnbCharts import sankeyChart sankeyChart(node_df,link_df,node_config={\"name_col\":\"\",\"value_col\":\"\",\"info_col\":\"\"}, link_config={\"src_col\":\"\",\"dst_col\":\"\", \"value_col\":\"\",\"info_col\":\"\",\"degree_col\":\"\"}, title=\"\",height=\"1080px\",width=\"100%\") 接口说明： node_df,link_df：数据集，类型：pandas.DataFrame node_config：节点相关配置项 \"name_col\"：设置节点对应的数据列 \"value_col\"：设置节点对应的数值（数值越大，节点的柱子越宽） \"info_col\"：节点需显示的详细消息 link_config：边的相关配合项 \"src_col\"：源节点的标识 \"dst_col\"：目标节点的标识 \"value_col\"：设置边对应的数值（数值越大，边的线条越粗） \"info_col\"：边上需显示的详细消息 \"degree_col\"：控制边的透明度（数值越大，线条越明显） title：图表名称 height：高度，格式：px 或百分比 width：宽度，格式：px或百分比 样例： from snb_plugin.snbcharts.SnbCharts import sankeyChart sankeyChart(df4,df2,node_config={\"name_col\":\"ip\",\"value_col\":\"msg_count\",\"info_col\":\"info\"}, link_config={\"src_col\":\"srcAddress\",\"dst_col\":\"destAddress\", \"value_col\":\"s_msg_count\",\"info_col\":\"info\",\"degree_col\":\"opacity\"}, title=\"\",height=\"1080px\",width=\"100%\") Table组件 Table组件除用作展示数据集，同时也具备一定的可视化交互能力，如对特征值进行条件筛选和排序。 创建 鼠标移动至单元格的下边界，当显示悬浮操作框时，单击更多类型，然后选择Table。 Table使用 选择数据集 可自定义显示的行数（默认200行） 可自定义数值的小数位数（默认保留2位小数） 单击字段标题可进行排序（初始状态、升序、降序） 点击字段标题右侧筛选按钮可进行逻辑条件筛选 通过接口自定义Table 除使用Table组件外，SNB也提供了Table的开放接口。用户也可通过Python调用__SNB_DisplayTable接口自定义显示Table __SNB_DisplayTable(df,rownum=200,height=\"520px\", width=\"100%\",PageSize=10,nd=2) 接口说明： df：数据集，格式：pandas.DataFrame rownum：显示行数，格式：int height：高度，格式：px 或百分比 width：宽度，格式：px或百分比 PageSize：单页显示数量，格式：int nd：用于控制数据集中数值类型小数点后保留几位小数，格式：int。默认保留两位小数 "},"NoteBook/selfAnalysis.html":{"url":"NoteBook/selfAnalysis.html","title":"自助分析组件","keywords":"","body":"SNB_自助数据分析 为什么 数据分析往往受到中心化架构的限制，需要大量的计算资源和时间，传统的商务智能（BI）也比较重型，有一定的使用门槛，同时数据分析过程中存在数据隐私和安全性问题。于是数据分析的去中心化是我们亟待需要解决的问题，打造一款去中心化、轻量级的、能保护用户隐私安全的数据分析工具显得极为重要。而SmartNotebook平台中的SNB_自助分析组件正是具有这样的特性。 是什么 SNB_自助分析组件结合了DuckDB-Wasm、Graphic Walker和Notebook的相关特性，形成了一个高效的、去中心化、自助工具组件，用户在浏览器中使用SmartNotebook平台，通过notebook生成Graphic Walker用户数据可视化界面，在本地轻松便捷地进行数据探索和分析，然后将分析结果保存到SmartNotebook的服务端或者云端，供决策者洞察其中的数据价值，做出对应的决策。具体原理如下图所示： SNB_自助数据分析工具采用类似Tableau和PowerBI的展现方式，提供了一个拖拽式、交互式的可视化探索分析界面，能够充分利用客户端的算力，对大数据量进行高效支持。它简化了数据探索的操作，使分析师能够轻松应对多种分析场景，展现出强大的适应性。 如何用 创建自助数据分析组件 鼠标移动至单元格的下边界，当显示悬浮操作框时，单击更多类型，然后选择自助分析。操作步骤：1.准备数据：创建一个DataFrame变量，存放你的数据（也支持数据文件上传）；2.选择你要分析的数据源（若无，则先去创建一个DataFrame变量）；3.你可以通过下拉“主题类型”或“风格”选项来调整分析界面的视觉效果；4.点击单元格左上方的“执行”图标按钮，即可得到一个数据/可视化探索界面，如下图所示： 专题分析管理 1. 保存专题分析 点击单元格右边的图标，在弹出的对话框中输入“专题名称”,点击“提交”，即可保存该专题。 在专题分析管理页面可以查看到已保存的专题，你可以点击进入查看或分析。 2. 配置权限 在这里配置该专题分析的查看权限，设置谁可以看，只有勾选过的用户才可以查看。 开始分析 分析界面设有“数据”和“可视化”两个选项卡，默认是展示“可视化”部分，数据探索分析主要是在“可视化”界面进行。 1. 数据部分 内容区域展示的是数据字段的概要情况，你可以粗略地查看数据的分布情况、缺失值或者异常值等,如下图所示： 2. 可视化部分 工具栏位于顶部 每个图标按钮的功能如下所述： 图标 功能名称 说明 撤销/重做 进行撤销/重做操作。 聚合度量 使用“求和”、“平均值”和“计数”等方法对数据进行聚合。 标记类型 在不同的图表类型之间切换，支持条形图、折线图、面积图、痕迹图、散点图、表格等，默认是‘自动’类型。 堆叠模式 创建堆叠图表或规范化图表，默认是“堆叠”图表。 转置 将图表中的行和列进行交换，即原先的列变为行，将原先的行变为列。 升序/降序排序 按照数据的大小顺序对图表中的内容进行升序/降序排列。 添加计算字段（度量值） 若已有的数据源中缺少分析所需的数据，需要对数据进行计算，则可以添加一个计算值。 坐标系缩放 对坐标轴进行伸缩，以改变坐标轴的显示范围和分辨率。 尺寸模式 对图表的大小进行设置的方式。它包括固定尺寸、自适应尺寸和适应容器大小三种模式。 坐标系模式 默认通用坐标系，还可以设置地理模式。 图表调试 默认关闭，若打开，则图表右上方会出现一个图标按钮，可以进行调试操作，如图所示： 导出 将图表以图片的形式导出，支持png、svg和base64三种格式。 导出csv 将结果数据以csv的形式导出。 配置 图表配置相关的一些设置，比如图表颜色、坐标轴最大值/最小值、数据格式等,如图所示： 代码 可以查看该组件的代码形式，也可以将该代码插入到一个新的单元格，还支持将生成的图表上传到图表库（后面会再提及该功能）。 设置上限 设置能展示的最大数据量，比如最终绘制图表的数据有100条数据，而设置了上限为50，那么图表中只会展示前50条数据。 打开数据绘板 打开一个类似绘板的界面和工具，用于数据清洗、数据建模和数据探索，你可以通过画笔和橡皮来随意探索。注：创建绘制字段前需要在x和y轴上分别放置一个字段来创建绘制字段，同时必须先关闭聚合。 在分析界面的左侧，字段列表中列出来所有的可选字段类型，这些字段都来源于数据源中的列。你可以通过简单的拖拉拽将字段拖放至你想放置的通道中（如列、行、筛选器、颜色、透明度、大小、形状和信息通道），然后就可以通过可视化的方式来分析这些数据。 对于度量，你可自由的选择合适的聚合类型（平均、求和、标准差等） 你可以通过调整不同的标记类型来展现不同的图表形式，如散点图等。 你也可以比对多个不同的度量，只需将他们都拖到行或列中来创建拼接视图，行和列都支持多个字段。 当完成自助探索，你可以选择将结果导出到文件，当下次分析时，便可快速导入之前分析的结果。 添加计算字段 功能用途：在多种场景下可以使用计算字段，比如对数据进行分箱、转换字段的数据类型、对已有字段进行聚合操作、计算比率等。 1.点击工具栏中的图标按钮； 2.输入计算字段的名称。在此示例中，该字段称为总分数；3.输入计算该字段的SQL表达式，在此示例中，书写以下表达式：home_score + away_score,该表达式将home_score和away_score相加，返回两数之和；4.点击添加按钮，即可添加，由于它返回一个数字，所以新字段被添加到度量字段中。 分箱 分箱是指将数据分成不同的 组或类别。在统计学和数据分析中，分箱常常用于将连续数据分成离散的区间，例如年龄分组、收入水平分组、分数分组等。在编程中，分箱也常用于数据预处理和特征工程，以便进行机器学习和数据分析。自助分析组件支持对字段的分箱，在可视化区域的度量通道中，可以做以下步骤进行分箱： 由于分箱是讲数据离散成组或者类别，所以分箱得到的字段属于维度，所以这时在维度通道就能看到分箱后的新字段bin10(Length),默认是分10箱（组），如图所示： 语义类型 在可视化或数据分析工具中数据编码很重要，因为不同的通道对不同语义的数据具有不同的操作。如果指定了字段，就应该描述它所代表的数据编码类型。SNB自助分析工具中支持的数据类型有定量（quantitative）、名义（nominal）、序列（ordinal）和时间（temporal）四种。quantitative：定量类型表示可以进行数学测量和操作的数据，例如身高、人数、销售额等。nominal： 名义类型表示一种没有任何固定顺序的类别或标签，例如颜色、产品型号、各厂商名称等。ordinal： 序列类型表示具有明确顺序或排名，但它们之间的差异不是一个恒定的值。例如从“非常差”到“非常优秀”的业绩好坏程度、“很满意”到“非常满意”的服务评级等。temporal：时间类型表示时间或者日期。它能以多种格式存在，例如时间戳、年月日、时间间隔等。 数据绘板 数据绘板工具提供了一种在不中断可视化探索工作流的情况下转换、清理、标记区分数据的新方式。 图表库管理 1. 图表上传 点击工具栏中的图标按钮； 在弹出的对话框中，点击“上传”按钮，输入“图表名称”和选择“开放状态”，完成后点击“提交”，即可将图表上传至图表库中。 说明： 开放状态包括自己访问、WorkSpace内访问和开放访问三种。自己访问：表示该图表是私密的，只能由你访问；WorkSpace内访问：是指同一个WorkSpace的成员都能访问；开放访问：是指任何人都能访问。 2. 图表查看/修改 上传的图表可以从图表管理页面中查看，可以进入接着探索数据。 可以在这里修改图表的名称和开放状态。 数据分析名词解释 数据分析 数据分析包括收集、处理和解释大量数据的过程，旨在从中提取有用信息并形成结论，以支持决策制定和策略规划。 商业智能(BI) 商业智能又称商业智慧或商务智能，指用现代数据仓库技术、线上分析处理技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。 绝对数和相对数 绝对数是反应客观现象总体在一定时间、一定地点下的总规模、总水平的综合性指标，也是数据分析中常用的指标，比如地区总人口。 相对数是指两个有联系的指标计算而得出的数值，它反映客观现象之间的数量联系紧密程度的综合指标。相对数一般以百分比、倍数等表示。 百分比和百分点 百分比，也叫做百分率或百分数，是表示一个数是另一个数的百分之几，百分比的分母是100，也就是1%作为度量单位。 百分点，是指不同时期以百分数的形式表示的相对指标的变动幅度，1%是一个（百分）点。 频数和频率 频数是指一个数据在整体中出现的的次数；频率是某一事件发生的次数和总的事件数之比，频率通常用比例或百分比表示。 倍数和番数 倍数：用一个数据除以另一个数据获得，倍数一般用来表示上升、增长幅度，一般不表示减少幅度。 番数：指原来数量的2的n次方。 同比和环比 同比：指的是与历史同时期的数据相比较而获得的比值，反应事物发展的相对性。 环比：指与上一个统计时期的值进行对比获得的比值，主要反映事物的逐期发展的情况。 数据集 大量数据的集合。 变量 变量来源于数学，是计算机语言中储存计算机结果或者表示值抽象概念。变量可以通过变量名来访问。 连续变量 在统计学中，变量按变量值是否连续可分为连续变量和离散变量两种。在一定区间内可以任意取值的变量叫连续变量，其数值是连续不断的，相邻两个数值可以做无限分割，如身高、体重等变量。 离散变量 离散变量的各变量值之间都是以整数断开的，如何个数、件数等，都只能按整数计算。离散变量的数值只能通过计数所得。 定性变量 定性变量又叫做分类变量，观测的个体只能归属集中互不相容类别中的一种，一般用飞数字来表达其类别，这样的观测数据称为定性变量，例如性别、学历等。 度量和维度 在BI中，度量（Measure）是数字字段的数字值，例如分数；而维度(Dimension)是数据字段的定性值，比如学校名称或者科目名称。 快开始你的探索之旅吧！ "},"NoteBook/self-chart/bar.html":{"url":"NoteBook/self-chart/bar.html","title":"柱状图示例","keywords":"","body":"柱状图 柱状图是一种易于理解的数据呈现方式，非常适合展示不同类别或组别之间的数据和分布情况。 制作柱状图 在SmartNotebook平台中创建柱状图很简单，轻松几步就能绘制完成。下面将描述如何创建柱状图。 准备数据集 在SmartNotebook中新建一个Notebook页面。 上传你的数据到数据环境文件中。在工具侧边栏中找到\"数据资源\"界面，依次点击\"环境文件\"-\"文件上传\"，你可以选择csv、json、txt等格式的文件。 复制你刚上传的文件的路径，你可以通过pandas将数据读取进来并且赋值给一个新DataFrame变量。 Your browser does not support the video tag. 绘制柱状图 添加自助组件，选择数据集。 在\"可视化\"选项卡下，你能看到一个类似商务智能软件的一个用户界面。 通过拖拉维度/度量来轻松创建柱状图。 Your browser does not support the video tag. 柱状图和直方图 虽然直方图和柱状图看起来很相似，但他们是不一样的含义，其用途不一样。直方图是显示连续数据的分布，Y轴体现频次（出现的次数），而柱状图显示分类的数据，Y轴一般是类别对应的数值。柱状图 直方图 分段条形图 分段条形图，也称堆积柱形图，非常适合展示不同类别中数据的组成，每一条代表一个类别，条内的段代表构成该类别的不同部分。它可以清晰地展示不同类别数据之间的数量或比例关系，帮助人们更直观地比较数据。 水平柱状图 水平柱状图是一种用来比较不同类别数据之间差异的图表类型。它与垂直柱状图类似，但是数据条是水平放置的，而不是垂直放置的。它通常用于显示类别较多或类别标签较长的数据，因为这种布局可以更好地展示长标签而不会重叠。 双重柱形图 双重柱形图，也称为分组柱形图，通过在同一组数据上绘制两个相邻的柱形图来比较两组数据，并且能够显示两组数据的差异和趋势。一般情况下，双重柱形图用于比较两个相关的数据集，比如不同时间段或不同条件下的数据情况。 总结 柱状图的主要优点是直观易懂，能够清晰地展示数据的相对大小和趋势，适用于较小的数据集和少量的类别，也可以用于比较不同时间点的数据或者比较不同组的数据，帮助观察变化和趋势。然而，柱状图也有其局限性，例如在展示大量数据或者连续变量时，并不是最佳选择，需要根据具体的场景选择合适的可视化方式。 "},"NoteBook/self-chart/area.html":{"url":"NoteBook/self-chart/area.html","title":"面积图示例","keywords":"","body":"面积图 面积图又称区域图，强调数量随时间而变化的程度，是数据可视化中一种重要的图表类型，类似于折线图，但是其下方会有一个填充区域，也可以显示部分和整体的关系，还可用于引起使用者对总值趋势的注意。 创建面积图 你可以通过以下步骤来创建重叠或堆叠面积图： 在数据资源中导入你的数据，或者连接到你的在线数据库。 选择你的数据集，得到自助数据分析界面。 在可视化区域中，点击工具栏的“标记类型”图标，选择“面积”图表类型。 通过拖拉维度/度量到相应的通道位置，来创建面积图。 进行必要的调整，确保图表能有效传达你的数据洞察力。 面积图应用场景 面积图非常适合将随时间变化的数据进行可视化展示，或者比较多个系列以及识别趋势的情况，例如表示随时间而变化的的利润数据可以绘制在面积图中以强调总利润。 "},"NoteBook/self-chart/boxplot.html":{"url":"NoteBook/self-chart/boxplot.html","title":"箱线图图示例","keywords":"","body":"箱线图 箱线图，又称盒须图或箱型图，因形状如箱子而得名，是数据科学中一种很重要的图表类型，常用来展示数据的分布情况和异常值的存在。在箱线图中，有数据的最大值、最小值、中位数以及上下四分位数，可以帮助我们更好地理解数据的分布情况、比较不同组别的数据、发现异常值和监测数据变化。 创建箱线图 你可以通过以下步骤来创建箱线图： 在数据资源中导入你的数据，或者连接到你的在线数据库。 选择你的数据集，得到自助数据分析界面。 在可视化区域中，点击工具栏的“标记类型”图标，选择“统计箱”图表类型。 通过拖拉维度/度量到相应的通道位置，来创建箱线图。 箱线图的适用场景 箱线图适用于许多不同领域的数据分析和决策场景，通过观察数据的离散程度、集中趋势和异常值情况，揭示出关键的洞察和趋势。一些实际应用包括：品质管理：比较产品的质量数据情况。金融领域：用于比较不同投资组合的收益分布情况，帮助分析投资风险和回报。医学研究：用于比较不同治疗方案的疗效，观察不同组别患者的生存期分布情况。生产制造：用于监测生产线上产品的质量分布情况，发现异常值或设备故障。教育领域：用于比较不同班级或学校学生成绩的分布情况，发现优秀生源或需要关注的学生群体。市场营销：用于比较不同市场区域产品销售额的分布情况，了解市场需求差异。人力资源管理：用于比较不同部门或团队的绩效评分分布情况，发现优秀员工或问题部门。 "},"NoteBook/self-chart/heatMap.html":{"url":"NoteBook/self-chart/heatMap.html","title":"热力图示例","keywords":"","body":"热力图 热力图是数据可视化中的一种图表类型，它用来展示两个变量之间的关系，矩形的着色与指标或者第三个变量相对应，例如分析一个区域不同店铺位置的每月订单情况。 创建热力图 你可以通过以下步骤来创建热力图： 在数据资源中导入你的数据，或者连接到你的在线数据库。 选择你的数据集，得到自助数据分析界面。 在可视化区域中，点击工具栏的“标记类型”图标，选择“矩形”图表类型。 通过拖拉维度/度量到相应的通道位置，来创建热力图。 热力图的适用场景 热力图通常用来显示数据的相关性，适用于任何需要通过空间或位置信息来展示数据分布情况的场景，它可以帮助人们更直观、更易理解地了解数据背后的信息，一些主要的应用场景包括：网站分析：分析网页上的点击、浏览和交互数据，从而了解用户的行为模式和偏好，帮助网站进行优化设计。商业分析：在零售和商业环境中，热力图可用来分析顾客活动、购买行为和人流量，从而指导商业策略和决策。地图应用：在地图应用中显示人口的密集区、交通情况、犯罪率等位置相关的数据。生物医学研究： 展示基因表达模式、药物活性和疾病分布等生物信息数据，帮助研究者发现潜在的关联和规律 "},"NoteBook/self-chart/scatter.html":{"url":"NoteBook/self-chart/scatter.html","title":"散点图示例","keywords":"","body":"散点图 散点图是数据可视化中的一种图表类型，它的横轴和纵轴分别表示两个变量，每个数据点则代表了这两个变量的取值，展示为图表上的一个个的点。 创建散点图 你可以通过以下步骤来创建散点图： 在数据资源中导入你的数据，或者连接到你的在线数据库。 选择你的数据集，得到自助数据分析界面。 在可视化区域中，点击工具栏的“标记类型”图标，选择“散点”图表类型。 通过拖拉维度/度量到相应的通道位置，来创建散点图。 散点图的适用场景 散点图通常是用来探索和识别变量间的相关关系，一些主要的应用场景包括：关联分析：观察两个变量之间的相关性，看是否存在某种趋势或者联系。异常值检测：能快速识别出数据中的异常值。趋势预测：预测销售量、价格变化等。实验分析： 评估实验数据的有效性，例如比较两组测试的实验结果数据。 结论 总之，散点图是一种非常直观、实用的数据可视化方法，适用于分析和展示多种不同类型的数据关系。 "},"NoteBook/machine-learning/":{"url":"NoteBook/machine-learning/","title":"机器学习组件","keywords":"","body":"机器学习（Machine Learning）   机器学习（Machine Learning）是人工智能(AI)的核心，是使计算机具有智能的根本途径，其目标是让计算机系统通过学习数据和经验来改善其性能。简单的来说，机器学习算法能够从数据中学习模式，并用这些学习到的模式来做出预测和决策，而无需显式的编程。  SmartNotebook中的机器学习组件是基于scikit-learn(sklearn)库封装的用于降维、聚类、分类、回归任务的低代码组件，这些低代码组件具有以下显著优点： 简单易上手  通过低代码的形式，用户可以轻松调用复杂的机器学习算法，无需深入了解底层实现细节。极大地降低了机器学习的使用门槛，适合各类用户从初学者到专家。 集成数据处理功能  组件内置了数据预处理功能，包括数据清洗、特征缩放、特征选择等步骤，使得用户可以在一个统一的平台上完成从数据预处理到模型训练和评估的全过程。 功能全面  组件涵盖了广泛的机器学习任务，包括降维、聚类、分类、回归等，其中降维组件支持的算法有主成分分析（PCA）、多维尺度法、独立成分分析、截断奇异值分解、t-SNE以及流形近似和投影；聚类组件支持的算法有KMeans、均值漂移以及层次聚类；分类组件支持逻辑回归、决策树、随机森林、支持向量机（SVM）、K近邻以及朴素贝叶斯算法；回归组件支持线性回归、K近邻回归以及决策树回归算法。每种算法能设置对应的参数，可以根据需要进行调整，满足各种应用场景的需求。 灵活性和可扩展性  用户可以通过调整组件的参数，灵活地配置和优化机器学习模型。支持多种模型和参数调优方法，确保模型性能达到最佳状态。 "},"NoteBook/machine-learning/dim_reduction.html":{"url":"NoteBook/machine-learning/dim_reduction.html","title":"降维算法","keywords":"","body":" 界面介绍 左侧为数据集的字段列表，中间为算法的主要操作区域，右侧为评价指标展示区域，展示数据结果。 相关算法说明 算法名称 概念 优点 适用场景 主成分分析（PCA） 主成分分析（PCA）是一种统计方法，用于将高维数据投影到低维空间。它通过线性变换将原始数据转换到一个新的坐标系中，使得最大的方差（即数据的最大变化）投影到新的坐标系的第一轴，第二大的方差投影到第二轴，依此类推。 降低数据维度的同时，尽可能保留数据的方差。 数据预处理、图像压缩、特征提取 多维尺度法（MDS） 多维尺度法（MDS）是一种降维技术，旨在将高维数据点嵌入到低维空间中，保留原始数据点之间的距离关系。MDS通过优化方法最小化高维数据点之间的距离与低维嵌入点之间距离的差异。 能够处理非线性数据关系。 心理学和社会学中的相似性分析、市场研究中的消费者偏好分析 独立成分分析（ICA） 独立成分分析（ICA）是一种统计和计算技术，用于将多变量信号分解为彼此统计独立的非高斯信号。ICA假设观测数据是由若干个独立信号线性混合而成，通过分离这些信号，可以发现隐藏在数据中的独立成分。 能够揭示数据中的独立信号源。 生物医学数据分析，如脑电图（EEG）分析 截断奇异值分解（Truncated SVD） 截断奇异值分解（Truncated SVD）是奇异值分解（SVD）的一种形式，通过保留最大的奇异值及其对应的奇异向量来降低数据的维度。SVD将一个矩阵分解为三个矩阵的乘积，截断SVD则在分解后仅保留前k个奇异值及其对应的奇异向量。 有效减少数据维度，保留主要信息。 文本分析中的潜在语义分析（LSA）、图像压缩 t-SNE（t-Distributed Stochastic Neighbor Embedding） t-SNE是一种降维技术，特别适合高维数据的可视化。它通过将高维数据点嵌入到低维空间中，最大程度地保留数据点在高维空间中的邻近关系。t-SNE通过构建数据点间的条件概率分布，最小化高维和低维分布之间的KL散度来实现降维。 在低维空间中保持数据点的局部结构。 高维数据的可视化，如图像和文本数据 流形近似和投影（UMAP） 流形近似和投影（UMAP）是一种非线性降维方法，通过近似高维数据的流形结构，将数据嵌入到低维空间。UMAP利用拓扑数据分析和高效的数值优化技术来实现数据的降维。 1. 计算效率高，适合大规模数据集。2. 能够很好地保留数据的局部和全局结构。 数据可视化、聚类和分类的预处理 操作步骤 1.加载数据 你可以使用pandas库从csv、json、txt等格式的文件中加载数据，也可以直接从数据库中加载数据。这里以文件加载的方式进行介绍： 2.添加降维组件 将鼠标光标移动至单元格的下边界，点击“更多类型”按钮，选择ML/AI类型下的“降维”，点击后即可添加完成。 3.选择数据集 在组件的左上角单击下拉框，选择你需要处理的数据集。选择完成后，左侧的字段列表区域将展示该数据集的所有字段，包括字段名称和字段类型（123表示数值，Abc表示文本），此外，如果字段比较多，这里也支持字段搜索。 4.选择算法类型 点击算法类型下拉框，选择合适的降维算法。例如选择“主成分分析”进行PCA降维。 5.选择特征（列） 根据具体的需求选择需要进行降维的特征（列），例如这里选择 Sepal_Length、Sepal_Width、 Petal_Length、Petal_Width四列作为特征，只需要将这四个字段拖入“包含列”区域即可，或者在字段上单击左键，在弹出的功能菜单中选择“添加到包含列”或“添加排除列”。其中“所有列”开关可控制“排除列”是否有效，可以根据需要开启或关闭。 6.调整参数配置 例如主成分分析算法可以设置如下参数： 合并源DF：表示降维后得到的结果数据是否要包含源数据集中的列。 维度数量：表示要将数据降到多少个维度。 白化处理：将数据进行标准化，使得每个特征（列）的均值都为0，标准差都为1（即具有零均值和单位方差）。这样处理可以消除不同特征间量纲的影响，使得特征值在相同的尺度下进行比较和处理，有助于提升某些机器学习算法的性能。 随机种子：在机器学习和数据分析中，设置随机种子可以确保每次运行代码时得到的随机结果是一致的。在调试代码、结果复现等情况下比较适用。 7.执行降维 定义保存模型和保存操作后数据结果的变量（添加组件时系统也会给出默认变量，可根据需要自行修改）。 你可以将降维后的结果数据进行可视化，观察数据之间规律，例如绘制散点图。 常见问题和解决方法 数据类型不匹配 确保所选择的列数据类型与算法要求相匹配，比如主成分分析需要的数据类型是数值型。 参数设置错误 检查维度数量、白化处理等参数是否正确。 数据缺失 如果数据中存在缺失值，考虑预处理填充缺失值或者删除。 "},"NoteBook/machine-learning/cluster.html":{"url":"NoteBook/machine-learning/cluster.html","title":"聚类算法","keywords":"","body":" 界面介绍 左侧为数据集的字段列表，中间为算法的主要操作区域，右侧为评价指标展示区域，展示数据结果。 相关算法说明 聚类是数据挖掘中的一种技术，旨在将数据对象分成若干个组，使得同一组中的对象彼此之间相似度高，而不同组之间的对象相似度低。以下介绍三种常用的聚类算法，并做出对比。 算法名称 概念 优点 缺点 适用场景 均值漂移（Mean Shift） 均值漂移是一种基于密度的聚类算法。它通过平滑密度估计将数据点移动到高密度区域的模式，即均值。算法不断迭代计算点的均值，并将每个点移动到该均值，直到所有点的移动幅度小于某个阈值。 不需要指定簇的数量；能够检测任意形状的簇。 计算复杂度高，尤其是高维数据；对于稀疏数据效果不佳。 图像分割、目标跟踪 KMeans KMeans是一种基于划分的聚类算法，通过迭代优化将数据点分配到K个簇中。算法的目标是最小化簇内点到簇中心的距离平方和（即簇内误差平方和）。 算法简单易懂，计算速度快；对于大规模数据集效果较好 需要预先指定簇的数量K；对初始中心点敏感，可能导致局部最优解；只能检测球形簇。 图像压缩、 市场细分 层次聚类（Hierarchical Clustering） 层次聚类是一种基于树状结构的聚类方法，通过逐步合并或拆分簇，生成一个聚类树（树状图）。根据聚类树，可以任意选择层次进行聚类。 不需要预先指定簇的数量； 生成的树状结构可以提供聚类的多层次信息。 计算复杂度高，尤其是大规模数据集；对噪声和离群点敏感。 基因表达数据分析、社交网络分析 操作步骤 1.加载数据 你可以使用pandas库从csv、json、txt等格式的文件中加载数据，也可以直接从数据库中加载数据。这里以文件加载的方式进行介绍： 2.添加聚类组件 将鼠标光标移动至单元格的下边界，点击“更多类型”按钮，选择ML/AI类型下的“聚类”，点击后即可添加完成。 3.选择数据集 在组件的左上角单击下拉框，选择你需要处理的数据集。选择完成后，左侧的字段列表区域将展示该数据集的所有字段，包括字段名称和字段类型（123表示数值，Abc表示文本），此外，如果字段比较多，这里也支持字段搜索。 4.选择算法类型 点击算法类型下拉框，选择合适的聚类算法。例如选择“KMeans”算法进行聚合。 5.选择特征（列） 默认情况下，“所有列”选项是开启的。如果您不希望使用排除列，可以关闭“所有列”选项。 在“包含列”框中，从字段类表区域拖动所需的列。例如，将“Sepal_Length”和“Sepal_Width”拖动到“包含列”框中。 在“排除列”框中，拖动要排除的列，将不需要的列拖动到“排除列”框中。 6.调整参数配置 通过合理设置这些参数，算法的性能和聚类结果的质量。根据具体的数据集和应用场景，调整参数以获得最佳的聚类效果。 例如KMeans算法可以设置如下参数： 合并源DF：表示降维后得到的结果数据是否要包含源数据集中的列。 初始化方式：初始化方式决定了初始簇中心的选择方式，不同的初始化方法可能导致不同的聚类结果，尤其是在数据点分布较为复杂的情况下。这里提供了k-means++和随机两种初始化方式，其中k-means++使用一种智能的方式初始化中心，能够加速收敛；random则是随机选择数据集中的点作为初始中心。 运行次数：运行次数是指KMeans算法运行的独立实验次数。每次运行从不同的初始簇中心开始，最终选择聚类结果最优的一次。这有助于避免局部最优解，增加得到全局最优解的概率。 最大迭代数：最大迭代数是指在单次运行中，算法允许的最大迭代次数。算法在每次迭代中更新簇中心，直到中心不再变化或达到最大迭代次数。设置过小的迭代次数可能导致算法未能完全收敛，设置过大则可能导致不必要的计算。 随机种子：不同的随机种子可能导致不同的初始簇中心，从而影响聚类结果。在机器学习和数据分析中，设置随机种子可以确保每次运行代码时得到的随机结果是一致的。在调试代码、结果复现等情况下比较适用。 簇数：簇数是指要将数据分成的簇的数量，是KMeans算法的核心参数。选择适当的簇数对于得到有意义的聚类结果非常重要。簇数可以通过经验、业务需求或使用如肘部法、轮廓系数等方法来确定。这里以“k-means++”的初始化方式、运行次数设为10，最大迭代数设为300，簇数为3为例，对Sepal_Length和Sepal_Width字段数据进行聚类。 7.执行聚类 定义保存模型和保存操作后数据结果的变量（添加组件时系统也会给出默认变量，可根据需要自行修改），执行后可得到以下聚类结果，可以查看结果数据，同时也通过散点图对数据进行了可视化展示。 可以看出这次聚类操作将数据分成了1、2、3三类，同一组中的对象（同一种颜色的数据点）彼此之间相似度高，而不同组（不同颜色的数据点）之间的对象相似度低。 8. 预测 我们可以使用上面的模型来进行预测一下[6,3]属于那种花,使用predict方法： 可以看出这个模型给出的预测值为2类。 常见问题和解决方法 数据类型不匹配 确保所选择的列数据类型与算法要求相匹配，比如主成分分析需要的数据类型是数值型。 参数设置错误 检查运行次数、最大迭代数、簇数等参数是否设置正确。 数据缺失 如果数据中存在缺失值，考虑预处理填充缺失值或者删除。 聚类结果不理想 调整簇数，运行多次实验，以找到最佳的聚类数量。进行特征选择或标准化处理，以改善聚类效果。 "},"NoteBook/machine-learning/classification.html":{"url":"NoteBook/machine-learning/classification.html","title":"分类算法","keywords":"","body":" 界面介绍 左侧为数据集的字段列表，中间为算法的主要操作区域，右侧为评价指标展示区域，展示模型的评估结果。 相关算法说明 分类算法通过对已知类别训练集的计算和分析，从中发现类别规则并预测新数据的类别。 算法名称 概念 优点 缺点 适用场景 逻辑回归（Logistic Regression） 逻辑回归是一种线性模型，广泛用于二分类问题。它通过逻辑函数（Sigmoid函数）将线性回归的输出值映射到0到1之间，从而输出预测概率。 易于实现和解释；计算效率高。 对非线性数据效果较差；容易受异常值影响。 医学诊断（如疾病预测）、市场营销（如客户分类） 决策树（Decision Tree） 决策树是一种树状结构，每个节点表示一个特征，每个分支表示该特征的可能取值，每个叶节点表示一个类别。通过对特征进行条件判断，决策树可以进行分类。 简单直观，易于解释；不需要标准化数据 容易过拟合；对噪声数据敏感。 客户流失预测、风险评估 随机森林（Random Forest） 随机森林是由多棵决策树组成的集成算法，通过对多个决策树的预测结果进行投票来决定最终分类结果。它利用了Bagging技术（Bootstrap Aggregating）和随机特征选择，增强了模型的泛化能力。 减少过拟合问题；对噪声数据鲁棒； 具有较高的准确性。 计算开销较大；模型解释性较差。 图像识别、金融风险预测 支持向量机（Support Vector Machine, SVM） 支持向量机通过找到最佳决策边界（超平面）将数据点分开，以最大化决策边界到最近数据点（支持向量）的距离。它可以通过核函数处理非线性分类问题。 能处理高维数据；适用于线性和非线性数据； 对小样本数据集效果好。 对大规模数据集计算开销大；模型参数调节较复杂。 文本分类、图像分类 K近邻（K-Nearest Neighbors, KNN） K近邻算法是一种基于实例的学习算法，通过计算新数据点与训练数据集中每个点的距离，选择距离最近的K个点，并根据这些点的类别进行分类。 实现简单，无需训练过程； 适用于多分类问题；可处理非线性数。 预测时计算开销大；对噪声敏感。 推荐系统、模式识别 朴素贝叶斯（Naive Bayes） 朴素贝叶斯是一种基于贝叶斯定理的概率分类算法，假设特征之间相互独立。尽管这种假设在实际中并不总是成立，但朴素贝叶斯在很多应用中表现良好。 实现简单，计算效率高； 对高维数据表现良好；能处理缺失数据。 假设特征独立，可能不符合实际情况；对连续数据的处理较为简单。 垃圾邮件过滤、文本分类 操作步骤 1.加载数据 你可以使用pandas库从csv、json、txt等格式的文件中加载数据，也可以直接从数据库中加载数据。这里以文件加载的方式进行介绍： 2.添加分类组件 将鼠标光标移动至单元格的下边界，点击“更多类型”按钮，选择ML/AI类型下的“分类”，点击后即可添加完成。 3.选择数据集 在组件的左上角单击下拉框，选择你需要处理的数据集。选择完成后，左侧的字段列表区域将展示该数据集的所有字段，包括字段名称和字段类型（123表示数值，Abc表示文本），此外，如果字段比较多，这里也支持字段搜索。 4.选择算法类型 点击算法类型下拉框，选择合适的分类算法。例如选择“支持向量机”算法进行分类。 5.选择特征（列）和目标列 默认情况下，“所有列”选项是开启的。如果您不希望使用排除列，可以关闭“所有列”选项。 在“包含列”框中，从字段类表区域拖动所需的列。例如，将“Sepal_Length”和“Sepal_Width”拖动到“包含列”框中。 在“排除列”框中，拖动要排除的列，将不需要的列拖动到“排除列”框中。 在“标签列”下拉框中选择目标列。 6.调整参数配置 例如支持向量机可以设置如下参数： 随机种子：在机器学习和数据分析中，设置随机种子可以确保每次运行代码时得到的随机结果是一致的。 测试集比例：控制数据集划分为训练集和测试集的比例，这个比例是一个介于0和1之间的浮点数，表示测试集的占比，例如比例为0.3表示将30%的数据用作测试集，70%的数据用作训练集。 正则强度导数：该参数控制模型的正则化强度，以防止过拟合。“C”是一个正数，控制着正则化项的权重。较小的“C”值会增加正则化强度，限制模型复杂度，从而防止过拟合。较大的“C”值会降低正则化强度，使模型更关注训练数据的分类准确性。 核函数：核函数用于将数据映射到更高维度，以解决线性不可分问题。核函数是支持向量机算法中很重要的部分，决定了模型如何在高维空间中找到最佳分割超平面。常用的核函数有线性核、多项式核、径向基核、Sigmoid核。 核函数 说明 线性核（linear） 适用于线性可分数据。 多项式核（poly） 适用于非线性数据，通过调整多项式的度数来控制映射到高维空间的复杂度。 径向基核（RBF，也称高斯核） 适用于非线性数据，能够将数据映射到无限维空间。 Sigmoid核（sigmoid，也称双曲正切核） 类似于神经网络中的激活函数，因此在某些情况下可以将支持向量机理解为一种特殊形式的多层感知器（MLP），但不如 RBF 核常用。 以测试集比例为0.3，使用核函数“rbf”、正则强度导数为1举例，选择Sepal_Length和Sepal_Width字段为特征列，Species为目标列进行分类操作。 7.执行分类 定义保存模型和保存操作后数据结果的变量（添加组件时系统也会给出默认变量，可根据需要自行修改），执行后可得到分类模型的评估指标和混淆矩阵。 从评估指标表中可以看出：Accuracy(准确率)为0.78，这表示模型预测正确的比例是78%。Mean Squared Error（均方误差）为0.22，反映预测值与实际值之间的平均平方误差。数值越小，误差越小。ROC Area under Curve（ROC曲线下面积）是评价分类模型性能的一个指标，值越接近1，表示模型性能越好。这里的ROC曲线下面积为0.92 ，表示模型有很高的区分能力。Cohen's Kappa是一个衡量分类一致性的重要指标，0.67 表示模型预测与实际分类之间有较好的一致性。F1 Score（F1分数）是模型精确度和召回率的调和平均数，0.78表示该模型在平衡精确度和召回率方面表现良好。从混淆矩阵可以看出：第一行（True Label为0）：有15个样本被正确分类成了0类，0个样本被错误分成了1类，0个样本被错误分成了2类；第二行（True Label为1）：有0个样本被错误分类成了0类，有11个样本被正确分成了1类，有4个样本被错误分成了2类；第三行（True Label为2）：有0个样本被错误分成了0类，有6个样本被错误分成了1类，有9个样本被正确分成了2类；类别0的分类效果最好，没有任何错误的分类；类别1和类别2的分类效果相对较差。总结：整体来看，这个分类模型的性能不错，尤其是在区分类别 0 上表现很好。然而，在区分类别 1 和类别 2 时，模型表现有待提高。建议进一步优化模型参数，或者尝试其他分类算法，以提高对类别 1 和类别 2 的分类性能。 8.预测 可看出预测结果为1类 常见问题和解决方法 数据缺失 数据集中有缺失值可能会导致训练和预测过程出错，如果数据中存在缺失值，考虑预处理填充缺失值或者删除。 标签列数据类型 标签列需为数值型，可以将目标列先处理成数值型，再进行分类。 数据不平衡 分类数据中某些类别的数据量明显少于其他类别，导致模型偏向于多数类。可以考虑重采样方法，或使用适合处理不平衡数据的算法，如调整类权重。 训练集和测试集划分 训练集和测试集划分不合理，可能导致模型过拟合或欠拟合。请确保使用适当的比例（如70/30或80/20）划分训练集和测试集，并考虑使用交叉验证来评估模型。 过拟合和欠拟合 模型在训练集上表现良好，但在测试集上表现不佳，说明模型过拟合或欠拟合。如果是过拟合，可以使用正则化技术、减少模型复杂度、增加训练数据；如果是欠拟合，可以考虑增加模型复杂度、添加更多特征。 参数配置 对参数配置不当，影响模型性能。可以先理解每个参数的意义和作用，根据具体任务合理配置参数。 模型选择不理想 不同的分类任务可能需要不同的模型，选择不合适的模型会导致性能不佳。可以考虑尝试多种模型并比较它们的性能，选择最适合具体任务的模型。 模型更新 模型在训练环境中表现良好，但在实际应用中表现不佳。所以在实际环境中测试模型时，需要监控模型的表现，并根据需要更新模型。调整类权重。 "},"NoteBook/machine-learning/regression.html":{"url":"NoteBook/machine-learning/regression.html","title":"回归算法","keywords":"","body":" 界面介绍 左侧为数据集的字段列表，中间为算法的主要操作区域，右侧为评价指标展示区域，展示模型的评估结果。 相关算法说明 分类算法通过对已知类别训练集的计算和分析，从中发现类别规则并预测新数据的类别。 算法名称 概念 优点 缺点 适用场景 线性回归（Linear Regression） 线性回归是最简单的回归算法，假设因变量与自变量之间存在线性关系。通过最小化误差平方和来找到最佳拟合线。 简单且容易实现；对线性关系的数据有很好的表现；计算速度快，适合大规模数据集。 无法处理非线性关系的数据；对异常值较为敏感；对多重共线性（特征之间高度相关）敏感 适用于因变量和自变量之间关系为线性且数据集不含大量异常值的情况 决策树回归（Decision Tree Regression） 决策树回归使用树结构进行回归预测。每个内部节点代表一个特征的决策，叶节点代表预测结果。它通过递归地将数据集划分为更小的子集来建立树结构。 简单直观，易于理解和可视化；能够处理非线性的数据分布；不需要大量的数据预处理；能够处理多种数据类型（数值型和分类型）。 容易过拟合，特别是当树的深度很大时；对数据的微小变化较为敏感；预测时的分段不连续，可能导致精度不如其他模型。 适用于数据结构复杂且特征之间存在强非线性关系的情况 K近邻回归（K-Nearest Neighbors Regression） K近邻回归通过寻找输入样本的 K 个最近邻居，使用这些邻居的平均值或加权平均值作为预测值。 简单且无需假设数据分布；能够处理非线性数据； 对特征选择和特征缩放较为敏感。 计算成本高（特别是大数据集）；存储成本高；对噪声数据和局部异常值较为敏感；难以处理高维数据（即“维度灾难”）。 特征空间较低且数据分布相对平滑 操作步骤 1.加载数据 你可以使用pandas库从csv、json、txt等格式的文件中加载数据，也可以直接从数据库中加载数据。这里以文件加载的方式进行介绍： 2.添加分类组件 将鼠标光标移动至单元格的下边界，点击“更多类型”按钮，选择ML/AI类型下的“回归”，点击后即可添加完成。 3.选择数据集 在组件的左上角单击下拉框，选择你需要处理的数据集。选择完成后，左侧的字段列表区域将展示该数据集的所有字段，包括字段名称和字段类型（123表示数值，Abc表示文本），此外，如果字段比较多，这里也支持字段搜索。 4.选择算法类型 点击算法类型下拉框，选择合适的分类算法。例如选择“线性回归”算法进行分类。 5.选择特征（列）和因变量列 默认情况下，“所有列”选项是开启的。如果您不希望使用排除列，可以关闭“所有列”选项。 在“包含列”框中，从字段类表区域拖动所需的列。例如，将“Sepal_Length”、“Sepal_Width”、“Petal_Length”和“Petal_Width”拖动到“包含列（即回归模型$$ y = b_0+b_1x_1+b_2x_2+b_nx_n $$中的$$ x_1,x_2,...,x_n $$）”框中。 在“排除列”框中，拖动要排除的列，将不需要的列拖动到“排除列”框中。 在“因变量列”下拉框中选择要观察的因变量（即回归模型$$ y = b_0+b_1x_1+b_2x_2+b_nx_n $$中的y）。 6.调整参数配置 例如线性回归算法中可以设置如下参数： 截距：在线性回归模型 $$ y = b_0+b_1x_1+b_2x_2+b_nx_n $$中，$$ b_0 $$是截距，$$ b_1,b_2,...,b_n $$是回归系数，而截距项$$ b_0 $$使得模型能够在x取值为零时也能给出一个预测值。 测试集比例：控制数据集划分为训练集和测试集的比例，这个比例是一个介于0和1之间的浮点数，表示测试集的占比，例如比例为0.3表示将30%的数据用作测试集，70%的数据用作训练集。 以开启截距项，测试集比例为0.3进行线性回归举例。 7.执行回归 定义保存模型和保存操作后数据结果的变量（添加组件时系统也会给出默认变量，可根据需要自行修改），执行后可得到回归模型的评估结果。 从评估结果中可以看出：R Square($$ R^2 $$)为0.89，这表示模型能够解释89%的数据变异，这是一个较高的值，说明模型具有较好的拟合效果。Mean Squared Error（均方误差MSE）反映预测值与真实值之间的平均平方误差。数值越小，预测精度越高，同时预测误差越小，这里0.07是一个较小的值，说明预测误差很小。Root Mean Squared Error (均方根误差RMSE)，是误差的标准差，也是用来评估模型的预测误差。这里的RMSE为0.26 ，表示模型的预测误差在0.26左右。Mean Absolute Error (平均绝对误差MAE)反映预测值与真实值之间的平均绝对差，值为0.21表示模型的预测误差较小。总结：该模型的的拟合度为0.89，说明模型能很好的解释数据的变异，模型拟合度较高；同时和预测精度相关的MSE、RMSE、MAE指标都较小，说明模型的预测误差较低，预测精度较高。但建议通过进一步的验证和分析，确保模型在各种条件下的稳健性和可靠性。 常见问题和解决方法 数据缺失 数据集中有缺失值可能会导致训练和预测过程出错，如果数据中存在缺失值，考虑预处理填充缺失值或者删除。 特征和因变量列数据类型 均需为数值型，可以将其先处理成数值型，再进行回归。 训练集和测试集划分 训练集和测试集划分不合理，可能导致模型过拟合或欠拟合。请确保使用适当的比例划分训练集和测试集，并考虑使用交叉验证来评估模型。 多重共线性（Multicollinearity） 自相关是指残差之间存在相关性，常见于时间序列，影响回归系数的估计。可以考虑添加滞后变量，捕捉时间序列的依赖性，或者针对时间序列数据，采用更复杂的时间序列模型。 自相关（Autocorrelation） 自变量之间存在高度相关性，导致回归系数的不稳定和解释困难。可以考虑去除高相关自变量，或将高度相关的自变量转换为独立的主成分，也可以添加正则化项来减少回归系数的方差。 模型欠拟合（Underfitting） 指模型过于简单，不能捕捉数据中的复杂关系，导致预测性能差。可以添加更多的特征或使用更复杂的模型，也可以考虑特征工程。 模型过拟合（Overfitting） 模型过于复杂，过于依赖训练数据中的噪声，导致对新数据的预测性能差。考虑移除不重要的特征来简化模型，或使用交叉验证选择合适的模型和参数。 参数配置 对参数配置不当，影响模型性能。可以先理解每个参数的意义和作用，根据具体任务合理配置参数。 "},"NoteBook/InputParams/InteractionComponents.html":{"url":"NoteBook/InputParams/InteractionComponents.html","title":"交互组件","keywords":"","body":"输入单元格（交互组件） 输入单元格 输入参数是SmartNoteBook的核心独特部分。 可以在Notebook视图中创建输入参数，然后根据需要将其添加到仪表板或者报告中。 添加输入单元格（Input） 输入单元格是添加不同用户输入以用作代码和 SQL 块中的变量的好方法。 添加输入单元格，您可以调整各种设置，例如变量名称和显示名称。探索给定输入类型的更多选项。 插入输入组件 添加输入单元格，选择要插入的输入单元格类型 设置输入组件的属性 点击输入组件的设置按钮，右侧弹出抽屉设置属性： 一般包含标签名仪表板中要显示的名称和Python变量名称的下文引用参数名。 变量名: Python变量的名称，以及在项目下游引用输入参数输出的方式。 设置输入组件的样式显示 点击输入组件的设置按钮，右侧弹出抽屉风格标签： 参考输入 输入存储为 Python 变量，例如，input_1可以在整个项目中引用，就像其他变量一样。 输入变量不能重新赋值，例如，input_1 = 123不会有效地将参数重新赋值给123。相反，您将创建一个新变量，该变量与输入参数无关，其名称input_1和值为123。 可以使用Jinja在 SQL 单元格中引用输入，使用类似 的语法。有关此示例，请参阅我们关于参数化 SQL 查询的教程。 输入单元格 下拉框 文本框 标签页 单选框 时间日期 按钮 "},"NoteBook/InputParams/selectInput.html":{"url":"NoteBook/InputParams/selectInput.html","title":"下拉框输入","keywords":"","body":"下拉框输入 根据用户从枚举数字或字符串列表中选择的单个值来参数化您的分析。 静态 静态值是手动输入的。 数组的集合 label是下拉框显示的名称 value是下拉框python变量引用的值 [{\"label\":\"业务类型a\",\"value\":\"a\"},{\"label\":\"业务类型b\",\"value\":\"b\"},{\"label\":\"业务类型c\",\"value\":\"c\"}] 动态 动态值允许您将下拉列表的可用选项从代码本身链接到数据框列、列表、numpy 数组或 Pandas 系列。 多选下拉框 如果开启多选选项则python变量输出变成以逗号分隔的（,）str 提示 下拉菜单将仅显示前 10,000 个结果，所有后续选项将被截断。 "},"NoteBook/InputParams/textInput.html":{"url":"NoteBook/InputParams/textInput.html","title":"文本框输入","keywords":"","body":"文本输入 根据用户输入字符串值来参数化您的分析。 文本设置 变量名是下文中用到的python 变量的名称 标签名是现实的名称 placeholer 是默认提示的文本 示例 "},"NoteBook/InputParams/tabInput.html":{"url":"NoteBook/InputParams/tabInput.html","title":"标签页输入","keywords":"","body":"标签页输入 根据用户从枚举数字或字符串列表中选择的单个值来参数化您的分析。 静态 静态值是手动输入的。 数组的集合 label是下拉框显示的名称 value是下拉框python变量引用的值 [{\"label\":\"业务类型a\",\"value\":\"a\"},{\"label\":\"业务类型b\",\"value\":\"b\"},{\"label\":\"业务类型c\",\"value\":\"c\"}] 动态 动态值允许您将下拉列表的可用选项从代码本身链接到数据框列、列表、numpy 数组或 Pandas 系列。 示例 "},"NoteBook/InputParams/radioInput.html":{"url":"NoteBook/InputParams/radioInput.html","title":"单选框输入","keywords":"","body":"单选框输入 根据用户从枚举数字或字符串列表中选择的单个值来参数化您的分析。 静态 静态值是手动输入的。 数组的集合 label是下拉框显示的名称 value是下拉框python变量引用的值 [{\"label\":\"业务类型a\",\"value\":\"a\"},{\"label\":\"业务类型b\",\"value\":\"b\"},{\"label\":\"业务类型c\",\"value\":\"c\"}] 动态 动态值允许您将下拉列表的可用选项从代码本身链接到数据框列、列表、numpy 数组或 Pandas 系列。 示例 "},"NoteBook/InputParams/timeInput.html":{"url":"NoteBook/InputParams/timeInput.html","title":"时间日期输入","keywords":"","body":"时间输入 根据用户时间/日期选择的范围来参数化您的分析。 基于日历的日期选择器，允许选择日期和时间（可选）。 时间范围 示例 时间点 示例 "},"NoteBook/InputParams/buttonInput.html":{"url":"NoteBook/InputParams/buttonInput.html","title":"按钮输入","keywords":"","body":"按钮输入 用户按钮操作行为分 下载和跳转。 跳转 点击按钮跳转到绑定的报表 下载 点击按钮下载绑定的DF "},"NoteBook/Dashboard.html":{"url":"NoteBook/Dashboard.html","title":"仪表板","keywords":"","body":"仪表板 仪表板（Dashboard）允许用户快速轻松地将逻辑视图中的元素组合成任何人都可以使用的交互式、美观的 Web 应用程序。提供一个直观的图形化界面，可以展示和解析大量的数据。它可以将复杂的数据集转化为更易理解的图表和图形，使得业务决策者能够迅速理解数据，并据此做出决策。 通过仪表板我们可以将原始数据转化为可行的见解和战略成果来提升你的决策过程 一个仪表板可以包含多种类型的视图，例如条形图、饼图、折线图、地图、表格等等。这些视图都是由数据驱动的，可以实时或定期更新。仪表板可以展示各种关键性能指标（KPI），比如销售额、客户满意度、员工绩效等。 仪表板主要特征如下： 支持将NoteBook中各种类型单元格输入、输出添加到仪表板 可通过拖拽或属性设置来改变图表的大小、位置甚至角度，实现自由布局 灵活的自定义设置功能（例如设置元素大小、背景颜色、背景颜色及水印等） 支持预览、分享和嵌入到数据应用或数据门户 通过调度计划定期更新仪表板数据 支持交互组件的动态刷新、数据下钻（功能开发和测试中） 创建/修改仪表板 要创建/修改仪表板，请打开相对应的NoteBook。在右上角点击，弹出仪表板的设计界面。 [!NOTE] 请注意，每个NoteBook只能创建和发布一个仪表板。如果您需要发布多个仪表板，请将您的NoteBook复制多个副本来实现。 操作按钮 图标 操作 解释 画布设置 对画布属性进行配置，如像素大小，背景设置等 小地图 打开/关闭画布小地图 上一步 回退到上一步的画布状态 下一步 前进到下一步的画布状态（用户之前有做上一步的操作） 清空画布 清空画布中的所有组件 适应屏幕 画布自适应调整到合适的大小和位置 隐藏左侧菜单 隐藏/显示左侧的操作按钮 隐藏右侧菜单 隐藏/显示左侧的操作按钮 保存 保存当前画布的状态 预览 生成预览链接，预览仪表板内容 发布/更新发布 仪表板设计完成/修改后生成发布链接 关闭 关闭仪表板界面（重新打开显示最后保存的画布内容） 画布设置 点击 可以对画布大小、背景及水印进行设置。 小地图 点击 可开启/关闭小地图显示。 预览 设计完成后，可以先点击 查看效果。 发布/更新发布 点击 可以发布正式的仪表板链接。 用户可以直接通过打开链接在网络浏览器中实时查看和互动这个仪表板。此外，这个链接也可以轻松地嵌入到其他应用程序中，为您的业务流程提供即时的数据洞察。如果需要，您也可以将此链接投射到大屏幕上，以便在团队会议或演示中展示数据。这种多元化的展示方式为数据分析带来前所未有的灵活性和方便性，让您可以随时随地获取到最新、最准确的业务洞察。 每当您对仪表板进行更改时，您的仪表板都不会自动重新发布。您需要在更改完之后重新保存并 “更新发布”。 [!NOTE] 已发布的仪表板的 URL 在更新发布后保持不变，因此您不必担心重新共享或在应用中修改URL的问题。 拖动/旋转 选中元素后可以按下鼠标拖动到合适的位置。 点击元素左上角的圆点并按下鼠标可以调整元素的角度。 元素设置 双击画布中的元素可以对元素的相关属性（像素大小、位置、层级和旋转角度）进行配置。 案例展示（销售KPI仪表板） "},"NoteBook/DashboardBase.html":{"url":"NoteBook/DashboardBase.html","title":"基本仪表板","keywords":"","body":"基础仪表板配置 基础仪表板是一种简化的仪表板应用，主要用于定期展示数据图表和文字说明。通过Notebook调度，仪表板可以定期生成和更新，而无需用户进行页面交互。 配置和特点 图表展示： 提供多种图表类型（如柱状图、折线图、饼图等）以可视化数据。 图表用于展示关键数据指标和趋势，帮助用户直观地理解数据变化。 文字展示： 在图表旁提供文字说明，以解释数据的含义和关键发现。 文字展示可以包括标题、注释和简要分析。 Notebook调度： 通过Notebook进行数据处理和图表生成。 设定Notebook定期调度任务，自动生成和更新仪表板内容，确保数据的实时性和准确性。 无页面交互： 仪表板主要用于展示数据，无需用户进行页面交互。 适合于需要定期查看数据报告的用户，例如管理层和决策者。 通过以上步骤，可以实现一个基础的仪表板，用于定期展示数据，无需用户进行页面交互，适合于需要定期查看数据报告的用户群体。 配置仪表板步骤： 1.添加仪表板单元 （包括Notebook基础单元格(输入，输出)、UI模版 2.编辑仪表板单元的基础属性（在相对仪表板左上顶点的x、y轴位置、单元的宽、高、层级基础属性） 3.删除仪表板单元 4.预览/保存仪表板 5.发布/更新仪表板 0. 仪表板节点命名 仪表板的每个单元都会被命名。 演示视频 Your browser does not support the video tag. 1. 添加仪表板单元（包括Notebook基础单元格(输入，输出)、UI模版） 1.1 添加Notebook单元格到仪表板中 点击Notebook左侧radio框，选中的Notebook的的input和output会自动排版到仪表板中。 演示操作： 1.2 添加UI模版到仪表板中 点击仪表盘左侧的模版区域，添加UI模版到仪表盘中。 UI模版类型：标题模版、背景模版、文本模版、装饰模版、主题模版。 模版定义请跳转模版定义 演示示例： 2.编辑仪表板节点的基础属性（在相对仪表板左上顶点的x、y轴位置、单元的宽、高、层级基础属性） 双击仪表板上需要编辑的节点、右侧弹出抽屉弹框，可以修改单元格基础属性（宽高、位置、层级等） 同时也支持鼠标操作： 改变(宽、高): 鼠标移入要修改的单元，拖动线框矩形柄则完成相对应的编辑操作。 改变(位置): 鼠标移入要修改的单元，鼠标右击不放，移动鼠标则完成相对应的移动操作。 演示示例 3.删除仪表板单元 删除如下图： a:鼠标移入要删除的单元，点击单元右上角的删除按钮。 b:点击Notebook 选中按钮，则也会删除右侧的单元。 4.预览/保存仪表板 设计完成后，可以先点击 查看效果。 5.发布/更新发布 点击 可以发布正式的仪表板链接。 用户可以直接通过打开链接在网络浏览器中实时查看和互动这个仪表板。此外，这个链接也可以轻松地嵌入到其他应用程序中，为您的业务流程提供即时的数据洞察。如果需要，您也可以将此链接投射到大屏幕上，以便在团队会议或演示中展示数据。这种多元化的展示方式为数据分析带来前所未有的灵活性和方便性，让您可以随时随地获取到最新、最准确的业务洞察。 每当您对仪表板进行更改时，您的仪表板都不会自动重新发布。您需要在更改完之后重新保存并 “更新发布”。 [!NOTE] 已发布的仪表板的 URL 在更新发布后保持不变，因此您不必担心重新共享或在应用中修改URL的问题。 更多高级设置 以上就是设计/保存/发布基本仪表板的演示流程。发布的仪表板都在 报告和看板 列表中 "},"NoteBook/DashboardInterac.html":{"url":"NoteBook/DashboardInterac.html","title":"高级互动仪表板","keywords":"","body":"高级交互仪表板配置 基础仪表板是一种简化的仪表板应用，主要用于定期展示数据图表和文字说明。通过Notebook调度，仪表板可以定期生成和更新，而无需用户进行页面交互。 除了基础功能外，仪表板还可以满足更高级的交互需求： 示例 1. 条件筛选与时间范围联动 演示示例 通过设置条件筛选和时间范围，可以动态展示数据的变化规律。 Your browser does not support the video tag. 2. 图表联动 演示示例 点击地图的某区域，根据该区域条件联动其他相应的图表，展示在特定条件下的数据变化。 Your browser does not support the video tag. 3. 条件跳转 演示示例 点击图表后，根据设定的过滤条件跳转到不同的仪表板页面，以展示更加详细的数据和分析。 3.1 点击图表跳转 Your browser does not support the video tag. 3.2. 点击按钮跳转 操作 1. 条件筛选 1.把互动组件添加到 左侧的仪表板中。 2.双击要关联互动的单元格。 3.弹出右侧抽屉，点击组件交互 4.设置关联互动单元格：引用互动组件（引用其它组件的全局变量）；执行单元格（改变当前组件的值，需要执行的单元格） 5.保存并预览 6.发布 Your browser does not support the video tag. [!NOTE] 请注意，每个互动组件都关联全局唯一一个python的全局变量。仪表板中互动组件关联的单元格必须有引用该变量，如果没引用即使刷新该组件数据也不起效果。 2. 日期筛选和交互组件联合查询 1.把互动组件都添加到 左侧的仪表板中。 2.双击要设置关联互动的单元格。 3.弹出右侧抽屉，点击组件交互 4.设置关联互动单元格：引用互动组件（引用其它组件的全局变量）；执行单元格（改变当前组件的值，需要执行的单元格） 5.保存并预览 6.发布 Your browser does not support the video tag. [!NOTE] 请注意，每个互动组件都关联全局唯一一个python的全局变量。仪表板中互动组件关联的单元格必须有引用该变量，如果没引用即使刷新该组件数据也不起效果。 3. 当前仪表板图表联动 交互组件联合查询我们上面图例已经介绍了，如下示例： 当我们需要点击图表，达到我们选择筛选组件的效果：如下图 1.把互动组件都添加到 左侧的仪表板中。 2.双击要设置关联互动的单元格。 3.弹出右侧抽屉，点击组件交互 4.设置《图表单击关联互动单元格》 5.保存并预览 6.发布 Your browser does not support the video tag. 4. 按钮跳转链接 => 带查询条件 按钮跳转带查询条件如下示例： Your browser does not support the video tag. 1.把互动组件都添加到 左侧的仪表板中。 2.双击要设置关联互动的单元格。 3.弹出右侧抽屉，点击组件交互 4.设置按钮的交互操作 5.保存并预览 6.发布 Your browser does not support the video tag. 5. 图表点击跳转不同报表 如下示例： Your browser does not support the video tag. 设置操作如下： Your browser does not support the video tag. 6. 按钮下载 按钮点击下载DF 如下示例： 设置操作如下： Your browser does not support the video tag. "},"NoteBook/kernel.html":{"url":"NoteBook/kernel.html","title":"科学计算引擎","keywords":"","body":"科学计算引擎 SmartNotebook 支持多种科学计算引擎，包括：Python、R语言、SageMath(数学软件)、Julia。默认SmartNotebook全栈功能是构建在Python生态上的。其他科学计算引擎各有各的优势，优势互补。 R语言：R语言是一种用于统计计算和数据可视化的编程语言和环境。它由Ross Ihaka和Robert Gentleman在1993年开发，专门为统计分析和图形展示设计。R语言提供了丰富的统计和图形功能，包括线性和非线性建模、经典统计检验、时间序列分析、分类、聚类等。其扩展包系统非常强大，用户可以通过CRAN（Comprehensive R Archive Network）获取各种功能的扩展包。R语言在数据科学、统计学、经济学、生物信息学等领域广泛应用，尤其在数据可视化和数据分析方面表现出色。具体配置参考：R语言 SageMath：SageMath是一个免费的、开源的数学软件系统，采用GPL协议。它整合了许多开源Python包，采用Python语言编写，但也支持其他语言。它的目标是创造一个可变的开源软件以替代Matlab、Magma、Maple 和 Mathematica。具体配置参考：SageMath数学软件 Julia语言：Julia语言是一种高性能的编程语言，专为数值和科学计算而设计。它于2012年发布，旨在结合C和Fortran的速度与Python和R的易用性。Julia支持并行和分布式计算，拥有丰富的数值函数库和优越的性能，特别适合大规模数据处理、机器学习、模拟和统计计算。其多重派发机制和强大的类型系统使得代码既高效又灵活。Julia语言在科学研究、金融分析、数据科学等领域日益受到青睐。具体配置参考：Julia语言 "},"NoteBook/R.html":{"url":"NoteBook/R.html","title":"R语言","keywords":"","body":"R语言计算引擎 R语言是一种用于统计计算和数据可视化的编程语言和环境。它由Ross Ihaka和Robert Gentleman在1993年开发，专门为统计分析和图形展示设计。R语言提供了丰富的统计和图形功能，包括线性和非线性建模、经典统计检验、时间序列分析、分类、聚类等。其扩展包系统非常强大，用户可以通过CRAN（Comprehensive R Archive Network）获取各种功能的扩展包。R语言在数据科学、统计学、经济学、生物信息学等领域广泛应用，尤其在数据可视化和数据分析方面表现出色。 R语言计算引擎的安装配置 SmartNotebook默认的部署镜像内没有内置R语言计算引擎，需要Node环境中进行安装R语言(r-base)和R的kernel包(IRkernel)。 1.配置apt安装源 echo \"deb https://cloud.r-project.org/bin/linux/ubuntu bionic-cran40/\" >> /etc/apt/sources.list # 根据提示添加 apt update提示 key信息使用apt-key 执行下面一行语句 apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 51716619E084DAB9 apt update apt list --upgradable 2.安装R语言(r-base) # 版本列表参考地址：https://cloud.r-project.org/bin/linux/ubuntu/bionic-cran40/ # 最新版本：4.4.1 apt-get install r-base R --version 3.R终端内安装IRkernel 包 install.packages('IRkernel') IRkernel::installspec(user = FALSE) 4.查看kernel list： jupyter kernelspec list kernel list 参考信息如下： Available kernels: python3 /opt/conda/share/jupyter/kernels/python3 ir /usr/local/share/jupyter/kernels/ir 创建NoteBook 在新建NoteBook对话框中\"选择计算引擎(Kernel)类型\"为\"R\"的选项。 输入NoteBook标题并选择对应的环境（需满足您购买的产品拥有创建R语言的环境，否则无法创建），最后点击提交。 [!warning|style:flat] 成功创建NoteBook后，用户无法在不同的kernel语言类型之间切换。 SNB对其他R语言内核的支持仍处于早期阶段，有些功能尚不完善，例如变量资源管理器、SQL单元格、模型视图及低代码插件不支持。 当前支持的功能 MarkDown 单元格 收藏 评论 资源和文件管理 大纲目录 环境及调度任务 版本管理 代码仓库 单元格的状态 代码格式 单元格代码补全 团队协作编辑 终端 快捷键支持 R语言的探索 下面是基本5段R语言代码示例，分别涵盖基本操作、数据集操作、统计分析、可视化和机器学习。以下是代码示例： 1.基本操作 # 基本操作示例 # 定义变量 a 2.数据集操作 # 数据集操作示例 # 使用内置数据集mtcars data(\"mtcars\") # 查看数据集的前4行 head(mtcars,4) # 选择数据集的子集 subset_mtcars 3.统计分析 # 统计分析示例 # 使用内置数据集iris data(\"iris\") # 简单的描述性统计 summary(iris) 4.可视化 # 可视化示例 # 加载ggplot2包 library(ggplot2) options(repr.plot.width=10, repr.plot.height=4) # 使用ggplot2创建散点图 ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + geom_point() + labs(title = \"Sepal Length vs Sepal Width\", x = \"Sepal Length\", y = \"Sepal Width\") 5.机器学习 # 加载必要的包 library(caret) # 机器学习 library(datasets) # 内置数据集 # 使用内置数据集iris data(iris) # 将Species转换为二分类问题（假设只关注Setosa和非Setosa） iris_binary % mutate(Species = ifelse(Species == \"setosa\", \"setosa\", \"non-setosa\")) # 创建训练和测试集 set.seed(123) train_index 6.安装包的示例 install.packages('ggplot2') "},"NoteBook/SageMath.html":{"url":"NoteBook/SageMath.html","title":"SageMath数学软件","keywords":"","body":"SageMath数学软件 SageMath 是一个免费的、开源的数学软件系统，采用GPL协议。它整合了许多开源Python包，采用Python语言编写，但也支持其他语言。它的目标是创造一个可变的开源软件以替代Matlab、Magma、Maple 和 Mathematica。 为使大家方便的了解、学习并使用SageMath，我们的SmartNoteBook通过引入SageMath引擎并细致地对兼容性做了优化和完善，充分利用NoteBook的特性，不仅减少大量复杂的安装和配置，而且做到可以让用户即开即用。 SageMath数学引擎的安装配置 SmartNotebook默认的部署镜像内没有内置SageMath语言计算引擎，需要Node环境中进行安装SageMath和SageMath的kernel包。 创建SageMath的notebook及示例代码 在新建NoteBook对话框中\"选择计算引擎(Kernel)类型\"为\"Sagemath\"的选项。 输入NoteBook标题并选择对应的环境，最后点击提交。 [!warning|style:flat] 成功创建NoteBook后，用户无法在不同的kernel语言类型之间切换。 接下来我们进入NoteBook后直接创建Code单元格，便可以编写并执行Sage代码了。 比如：当我们对整数20221208 进行素数因子分解 ，新建一个Code单元格 ，输入以下代码并点击执行： factor(20221208) 执行结果： 算术(SageMath as a Calculator) 这里我们介绍介绍一下如何像图形计算器一样使用 SageMath 的一些算术和函数命令。 基本算术 基础的算术运算符为加 + 、减 -、乘 * 、除 / 、指数 ^ 数字前面的符号-表示它是负数。 print('1+1=',1+1) print('103-101=',103-101) print('7*9=',7*9) print('7337/11=',7337/11) print('11/4=',11/4) print('2^5=',2^5) print('-11+9=',-11+9) -6 SageMath 遵守标准的操作顺序， 即PEMDAS (parenthesis, exponents, multiplication, division, addition, subtraction): 括号、指数、乘法、除法、加法、 减法。 print(2*4^2+1) print((2*4)^2+1) print(2*4^(2+1)) print(-3^2) print((-3)^2) 当两个整数相除时，有一个微妙之处：SageMath将返回分数或其十进制近似值。与大多数图形计算器不同，SageMath将尝试尽可能精确，除非另有说明，否则将返回分数。 print(11/4) print(11/4.0) print(11/4.) print(11.0/4) print(11/4*1.) 整数除法和因式分解 有时当我们使用除法时，除法运算符不会给我们所有想要的信息。比如，我们不仅想知道约化分数是多少，甚至想知道它的十进制近似值，或者想知道唯一商和余数是多少。我们可以使用运算符// 来计算商，使用运算符 % 用于余数。使用 divmod(）函数来同时计算获得商和余数。 print( 14 // 4) print( 14 % 4) print( divmod(14,4)) 我们知道当两个整数是否能整除，可以采用A/B余数是0，说明可以整除，但SageMath 整数有一个内置的方法可以专门用来检查一个整数是否整除另一个整数。 print(3.divides(15)) print(5.divides(17)) 与divides方法相关的还有一个方法divisors()，此方法可以返回指定整数的所有正除数的列表。 print(12.divisors()) 101.divisors() 我们知道当整数的除数只是1和它本身时，这个数字是素数。为了检查一个数字在SageMath中是否是素数，我们可使用方法is_prime() print(153.is_prime()) (2^19-1).is_prime() factor()可计算整数的素因数分解 print(62.factor()) 63.factor() 有兴趣简单地知道哪些素数除以整数，我们可以使用prime_divisors() 或 prime_factors()方法。 print(24.prime_divisors()) print(24.prime_factors()) print(63.prime_factors()) print(63.prime_divisors()) 求最大公约数和最小公倍数。 最大公约数（GCD）是所有这些公约数中最大的一个。 最小公倍数（LCM）是两个整数相除的最小整数。 print( gcd(14,63)) print( gcd(15,19)) print(lcm(4,5)) lcm(14,21) 标准函数和常量 SageMath几乎包含了人们在学习数学时遇到的所有标准函数。接下来我们将介绍一些最常用的函数：maximum、minimum、 floor、ceiling、trigonometric、exponential、logarithm 函数。我们还将看到许多标准的数学常数，如欧拉常数(e）、π 和黄金比例（ ϕ ）。 # max 最大值 print(max(1,5,8)) # min 最小值 print(min(1/2,1/3)) # abs 绝对值 print(abs(-10)) # floor 向下取整 print(floor(2.1)) # ceil 向上取整 print(ceil(2.1)) 当使用floor、ceil 时要特别小心，注意计算精度问题 print(floor(1/(2.1-2))) print(1/(2.1-2)) sqrt()该命令/函数计算实数的平方根。正如我们之前在分数中看到的那样，如果我们想要十进制近似值，我们可以通过给出一个十进制数作为输入来获得它。 print(sqrt(3)) print( sqrt(3.0)) 为了计算其他根，我们使用有理指数。SageMath可以计算任何有理数指数幂(SageMath can compute any rational power)。如果指数或基数是小数，则输出将是小数。 print( 3^(1/2) ) print( (3.0)^(1/2) ) print( 8^(1/2) ) print( 8^(1/3) ) SageMath 还支持所有标准三角函数，例如：正弦sin()和余弦 cos() print( sin(1) ) print( sin(1.0) ) print( cos(3/2) ) print( cos(3/2.0) ) 在SageMath内，我们完全处理的是π，而不是一些数字近似。但是，我们可以使用以下方法调用数值近似：pi.n() print(pi.n()) print(sin(pi)) print(sin(pi.n())) 我们看到，当使用符号时，SageMath 返回确切的结果。但是，当我们使用近似值时，我们会得到一个近似值。是 的10^{-16}简写，数字应为零，但近似值引入了错误。以下是使用符号、精确 π 与数值近似的几个示例: print( sin(pi/6)) print( sin(pi.n()/6)) print( sin(pi/4)) print(sin(pi.n()/4)) 继续我们的主题，有一些鲜为人知的特殊角度，可以巧妙地简化正弦或余弦的值。 print( sin(pi/10)) print( cos(pi/5) ) print( sin(5*pi/12) ) 其他三角函数、反三角函数和双曲函数也可用 print( arctan(1.0) ) print( sinh(9.0)) SageMath内与 π 类似，它有一个内置的数字符号常数e，即自然对数的底数。 print(e) print(e.n()) 我们使用命令:ln(x)、log(x)、log(x,b)，幂基e可以使用函数和通过将符号常数提高到指定幂来完成。 print( ln(e) ) print( log(e) ) print( log(e^2) ) print( log(10) ) print( log(10.0) ) print( log(100,10) ) print( exp(2) ) print( exp(2.0) ) print( exp(log(pi)) ) print( e^(log(2)) ) SageMath的高级运算 关于符号计算和数值计算 我们需要先了解符号计算和数值计算的区别。 符号计算（也称为符号化计算）是一种使用符号和数学公式来解决问题的方法。它利用符号和公式来表示数学概念，而不是使用数字。符号计算通常用于解决复杂的数学问题，因为它可以更好地表示数学概念，更容易理解。 例如，使用符号计算解决微积分问题时，可以使用符号表示微积分的概念，而不是使用数字。符号计算可以帮助我们更好地理解数学概念，并使用数学公式来解决问题。 符号计算可以使用专门的符号计算软件或编程语言，例如 Mathematica、Maple 和 SymPy等。这些软件可以帮助用户表示数学概念，并使用符号计算来解决问题。 数值计算是使用数字来解决问题的方法。它通常用于解决某些无法使用符号计算直接解决的问题。数值计算通常使用的科学计算软件有 Matlab、Octave 或 Python 的 NumPy 库。这些软件提供了大量的数值计算工具和函数，可以帮助用户解决各种数学问题。 总结：符号计算使用符号和数学公式来表示数学概念，而数值计算使用数字来解决问题。另外，符号计算通常用于解决复杂的数学问题，而数值计算则常用于解决无法使用符号计算直接解决的数学问题。 求解方程和不等式 在SageMath里，方程和不等式使用运算符 ==、>=、 print(9==9) print(9为了求解方程或不等式，我们可以使用命令solve()。 我们先来解决只有x一个变量的情况。我们知道方程可能有多个解的情况。当有多个解时，SageMath 会以列表的形式返回找到的所有解。 var('x') print( solve(3*x - 2 == 5,x)) print( solve( 2*x -5 == 1, x)) print( solve( 2*x - 5 >= 17,x)) print( solve( 3*x -2 > 5, x)) solve(2*x^2 - x + 1 == 0, x) print( solve( x^2 + x == 6, x)) solve( exp(x) == -1, x) solve()尝试不使用浮点数来表示方程的解，它将以符号的形式返回： print(solve( sin(x) == x, x)) print(solve( exp(x) - x == 0 , x)) print( solve( cos(x) - sin(x) == 0 , x)) sage: solve( cos(x) - exp(x) == 0 , x) 如果想得到解的数字近似值，我们可以使用命令find_root()。 print(find_root(sin(x) == x, -pi/2 , pi/2)) find_root(sin(x) == cos(x), pi, 3*pi/2) 声明多个变量 前面的内容，我们求解了方程中仅有一个变量的情况，并且我们总是使用x作为变量名，此时SageMath 会创建一个符号变量 x用于求解方程。如果要求解多元方程，我们就需要使用其他的符号变量，此时我们必须要先使用var()命令声明它。符号变量的名称可以是字母，也可以是字母和数字的组合。 注意：变量名称不能包含空格，例如“square root”不是有效的变量名称，而“square_root”可以。另外，如果在声明符号变量之前使用它将导致 NameError。 sage: y,z,t = var(\"y z t\") sage: phi, theta, rho = var(\"phi theta rho\") sage: x1, x2 = var(\"x1 x2\") 取消声明一个符号变量使用命令restore()，就像上面定义变量一样。 sage: restore('phi') 求解具有多个变量的方程 我们也可以用命令solve()求解线性方程组，前提是方程组中所有符号变量都已声明。另外，方程组必须以列表形式输入，最后跟符号变量。结果也是以列表的形式输出。当然，方程组可能是唯一解，也可能有无限多个解，或者压根没有解： print(solve( [3*x - y == 2, -2*x -y == 1 ], x,y)) print(solve( [ 2*x + y == -1 , -4*x - 2*y == 2],x,y) ) sage: solve( [ 2*x - y == -1 , 2*x - y == 2],x,y) sage: solve([ 2*x + 3*y + 5*z == 1, 4*x + 6*y + 10*z == 2, 6*x + 9*y + 15*z == 3], x,y,z) solve()对于大型方程组来说可能非常慢。对于这种情况，最好的办法是使用线性代数函数求解多个变量不等式，但这可能会导致表达式求解变的非常复杂，因为它们定义的区域很复杂。 在下面的示例中，SageMath 求出的解是一个列表，其中包含线的交点，接下来是两条射线，最后是两条射线之间的区域： print(solve([ x-y >=2, x+y 5, x-y微积分(Calculus) SageMath有许多命令可用于研究微分和积分，接下来我们一起熟悉一些这方面的函数使用。 var('g h') f(x) = x*exp(x) print(f) g(x) = (x^2)*cos(2*x) print( g) h(x) = (x^2 + x - 2)/(x-4) print(h) SageMath 用x |–>来告诉你，返回的表达式实际上是一个函数，而不仅仅是一个数字或字符串。这意味着我们可以像您期望任何函数一样计算这些表达式。 print( f(1) ) print( g(2*pi) ) print( h(-1)) 定义以上这些函数后，我们将研究如何使用 SageMath 来计算这些函数的极限。 极限(Limits) $$x \\rightarrow 1$$ 的极限 $$f(x) = xe^{x}$$是在SageMath中通过在SageMath中输入以下命令来计算的： limit(f, x=1) 我们可以对g(x)评估在x=2处的极限，$$g(x) = x^{2} \\cos(2x)$$ $$x \\rightarrow 2$$: limit(g, x=2) h(x)在x=4 处有一个不连续性，我们查看x趋近于4时h(x)的极限： limit(h, x = 4) 下面这个h(x)的图表说明为什么我们在使用计算机代数系统时必须要小心一点。 我们得到的x=4是一个垂直渐近线，其函数趋向于正无穷大。当x大于4时，当x趋近于4时，h(x)趋近于正无穷大；反之当x从负轴方向趋近于4时，h(x)趋近于负无穷大。我们可以使用 SageMath 提供的dir参数来确认方向。 print( limit(h, x=4, dir=\"right\") ) sage: limit(h, x=4, dir=\"left\") 导数(Derivatives) 接下来我们要做的是使用 SageMath 来计算我们之前定义的函数的导数。例如，要计算 $$f^{\\prime}(x)$$、 $$g^{\\prime}(x)$$、$$h^{\\prime}(x)$$ 我们将使用该命令。 fp = derivative(f,x) print(fp) gp = derivative(g, x) print(gp) hp = derivative(h,x) print( hp) 第一个参数是您要微分的函数，第二个参数是您想要微分的变量，例如： y = var('y') print( derivative(f,y)) print( derivative(g,y)) derivative(h,y) 计算导数函数后，我们可以使用solve()命令找到临界点： print(fp(10)) print(gp(pi/2)) print(hp(10)) solve( fp(x) == 0, x) 在点$$\\left(x, f\\left(x\\right)\\right)$$处构造与我们的函数相切的线是一项重要的计算，在 SageMath 中很容易完成。例如，以下命令将计算与点$$\\left(0,f(0)\\right)$$相$$f(x)$$切的直线。 T_f = fp(0)*( x - 0 ) + f(0) T_f 积分(Integrals) SageMath具有计算许多常见函数的定积分和不定积分的功能。我们将从计算我们之前定义的每个函数的不定积分（也称为反导数）开始。这将通过使用具有类似于integral() 的参数的命令来完成。 integral(f,x) 定积分 integral(f, x,0,1) 在上述每种情况下，SageMath 都会返回一个函数作为其结果。这些函数中的每一个都是一个常量函数，这就是我们所期望的。如前所述，SageMath 将返回保留最高精度的表达式，除非被告知，否则不会使用小数。告诉 SageMath 需要近似的一种快速方法是用数值近似命令n()来包装命令。 print( n(integral(f, x,0,1))) print(n(integral(g, x,0,1))) n(integral(h, x,0,1)) 泰勒级数扩展(Taylor Series Expansion) SageMath的另一个有趣的功能是可以计算围绕一个点的泰勒级数展开。首先，我们展示如何在 0 周围展开，也称为麦克劳林级数。让我们举一个函数的例子 $$g(x) = \\cos(x)$$。 g = cos(x); print(g) g_taylor = g.taylor(x,0,3) g_taylor f = exp(x^3)*sin(x-5); print( f) f_taylor = f.taylor(x,2,3); print(f_taylor) 现在，这种计算的结果可能有点难以可视化，因此，SageMath的另一个有趣功能是可以以Latex格式打印结果，这对眼睛来说要好得多。 print(f_taylor._latex_()) 打印输出： \\frac{1}{6} \\, {\\left(x - 2\\right)}^{3} {\\left(467 \\, \\cos\\left(3\\right) - 2130 \\, \\sin\\left(3\\right)\\right)} e^{8} + \\frac{1}{2} \\, {\\left(x - 2\\right)}^{2} {\\left(24 \\, \\cos\\left(3\\right) - 155 \\, \\sin\\left(3\\right)\\right)} e^{8} + {\\left(x - 2\\right)} {\\left(\\cos\\left(3\\right) - 12 \\, \\sin\\left(3\\right)\\right)} e^{8} - e^{8} \\sin\\left(3\\right) 我们可以把上面的Latex格式放到SNB的MarkDown代码块来执行会看到： $$\\frac{1}{6} \\, {\\left(x - 2\\right)}^{3} {\\left(467 \\, \\cos\\left(3\\right) - 2130 \\, \\sin\\left(3\\right)\\right)} e^{8} + \\frac{1}{2} \\, {\\left(x - 2\\right)}^{2} {\\left(24 \\, \\cos\\left(3\\right) - 155 \\, \\sin\\left(3\\right)\\right)} e^{8} + {\\left(x - 2\\right)} {\\left(\\cos\\left(3\\right) - 12 \\, \\sin\\left(3\\right)\\right)} e^{8} - e^{8} \\sin\\left(3\\right)$$ 统计学(Statistics) SageMath提供的基本描述性统计函数的使用。为了演示它们的用法，我们将首先生成一个从 0 到 100 的整数伪随机列表。我们来计算平均值、中位数、众数、方差和标准差。 data = [ int(random()*(100-0) + 0) for i in [ 1 .. 20 ] ] print(mean(data)) print(median(data)) print(mode(data)) print(variance(data)) print(std(data)) print(moving_average(data,4)) print(moving_average(data,10)) print(moving_average(data,20)) SageMath的可视化 SageMath是一个强大的开源数学软件，具有非常广泛的数学可视化功能。它可以生成2-D以及3-D图形，甚至可以制作动画图。 而且除SageMath本身包含了大量的可视化工具外，同时SageMath与Python的紧密结合，也使得它可以运用Python中与可视化和图形有关的一系列库。这些广泛的数学工具和功能可以帮助您通过图形和动画的形式来理解数学概念和模型。 具体来说，SageMath提供了以下可视化功能： 图形绘制：SageMath可以绘制多种数学函数，如曲线、曲面、等高线等。 动画制作：SageMath可以制作动画，通过动画来展示数学模型的变化过程。 交互式可视化：SageMath可以创建交互式可视化，允许用户通过拖拽、缩放等操作来探索数学模型。 图像处理：SageMath可以处理图像，包括对图像进行缩放、旋转、剪裁等操作。 图形和动画的导出：SageMath可以将图形和动画导出为多种格式，如PNG、SVG、GIF等，方便您在其他软件或文档中使用。 总的来说，SageMath的可视化功能非常强大，能够帮助您更直观地理解数学概念和模型。 函数可视化的理论 一元函数是一种特殊的函数，其中函数的输入和输出都是单个变量。一元函数的形式通常是 y=f(x)，其中 x 是输入变量，y 是输出变量。例如，函数 y=x^2+1 就是一个一元函数，其中 x 是输入变量，y 是输出变量。 隐函数是由隐式方程所隐含定义的函数。设F（x,y）是某个定义域上的函数。如果存在定义域上的子集D，使得对每个x属于D，存在相应的y满足F(x,y)=0，则称方程确定了一个隐函数。记为y=y(x)。 显函数是用y=f(x)来表示的函数，显函数是相对于隐函数来说的。 参数方程是一种特殊的方程，其中函数的一个变量是参数。例如，x=t^2+1 和 y=t+2 可以联立起来得到参数方程： x=t^2+1 y=t+2 在这个参数方程中，t 是参数。我们可以用不同的值来替换 t，然后求出对应的 x 和 y 值。参数方程常用于描述曲线或曲面，因为它可以用一组方程来描述多维几何图形。 对应以几类函数的定义，我们需要先了解SageMath中三个绘图函数plot()、implicit_plot()以及parametric_plot() plot函数是SageMath中的一个常用函数，用于绘制一元函数的图像。这意味着，如果你想绘制一个函数y=f(x)的图像，你可以使用plot函数。例如： sage: var('x') x sage: f(x) = x^2 sage: plot(f, (x,-2,2)) 这将在平面直角坐标系中绘制出函数y=x^2的图像。 相比之下，implicit_plot函数用于绘制二元函数的图像。这意味着，如果你想绘制一个函数f(x,y)=0的图像，你可以使用implicit_plot函数。例如： sage: var('x,y') (x, y) sage: f(x,y) = x^2 + y^2 - 1 sage: implicit_plot(f, (x,-2,2), (y,-2,2)) 这将在平面直角坐标系中绘制出函数f(x,y)=0的图像。 最后，parametric_plot函数用于绘制参数方程的图像。这意味着，如果你想绘制由两个一元函数x=f(t)和y=g(t)定义的曲线，你可以使用parametric_plot函数。例如 sage: var('t') t sage: f(t) = cos(t) sage: g(t) = sin(t) sage: parametric_plot((f, g), (t,0,2*pi)) 这将在平面直角坐标系中绘制出由x=cos(t)和y=sin(t)定义的圆。 2D图形 SageMath提供了广泛的二维绘图功能，它的底层渲染是使用matplotlib库完成的。 它可以支持以下图形图元函数： arrow() - an arrow from a min point to a max point. circle() - a circle with given radius ellipse() - an ellipse with given radii and angle arc()- an arc of a circle or an ellipse disk() - a filled disk (i.e. a sector or wedge of a circle) line() - a line determined by a sequence of points (this need not be straight!) point() - a point text() - some text polygon() - a filled polygon 支持以下绘图打印功能： plot() - plot of a function or other Sage object (e.g., elliptic curve). parametric_plot() implicit_plot() polar_plot() region_plot() list_plot() scatter_plot() bar_chart() contour_plot() density_plot() plot_vector_field() plot_slope_field() matrix_plot() complex_plot() graphics_array() multi_graphics() 支持以下日志打印功能： plot_loglog() plot_semilogx() and plot_semilogy() list_plot_loglog() list_plot_semilogx() and list_plot_semilogy() 包括以下各种图形功能： Graphics() is_Graphics() hue() [!Tip] 在每个函数名后面输入?，可以获得该函数的帮助和示例。 3D图形 Sage广泛支持3D图形，从基本形状到隐式和参数化绘图。支持以下图形功能： plot3d() - plot a 3d function parametric_plot3d() - a parametric three-dimensional space curve or surface revolution_plot3d() - a plot of a revolved curve plot_vector_field3d() - a plot of a 3d vector field implicit_plot3d() - a plot of an isosurface of a function list_plot3d()- a 3-dimensional plot of a surface defined by a list of points in 3-dimensional space list_plot3d_matrix() - a 3-dimensional plot of a surface defined by a matrix defining points in 3-dimensional space list_plot3d_array_of_arrays()- A 3-dimensional plot of a surface defined by a list of lists defining points in 3-dimensional space list_plot3d_tuples() - a 3-dimensional plot of a surface defined by a list of points in 3-dimensional space 支持以下基本形状： Box - a box given its three magnitudes Cone - a cone, with base in the xy-plane pointing up the z-axis Cylinder - a cylinder, with base in the xy-plane pointing up the z-axis Line - a 3d line joining a sequence of points Sphere - a sphere centered at the origin Text - a text label attached to a point in 3d space Torus - a 3d torus Point - a position in 3d, represented by a sphere of fixed size 支持以下基本形状的绘图功能： ColorCube() - a cube with given size and sides with given colors LineSegment() - a line segment, which is drawn as a cylinder from start to end with given radius line3d() - a 3d line joining a sequence of points arrow3d() - a 3d arrow point3d() - a point or list of points in 3d space bezier3d() - a 3d bezier path frame3d()- a frame in 3d frame_labels() - labels for a given frame in 3d polygon3d() - draw a polygon in 3d polygons3d() - draw the union of several polygons in 3d ruler() - draw a ruler in 3d, with major and minor ticks ruler_frame() - draw a frame made of 3d rulers, with major and minor ticks sphere() - plot of a sphere given center and radius text3d() - 3d text Sage还支持以下： tetrahedron() cube() octahedron() dodecahedron() icosahedron() 支持不同的查看器: 基于web的交互式查看器，默认使用Three.js JavaScript library, Jmol以及Tachyon ray tracer. 通过添加关键字参数来调用查看器，如viewer='threejs' ('jmol'或者 'tachyon') 并使用命令show（）显示任何三维图形。 Tachyon - create a scene the can be rendered using the Tachyon ray tracer Axis_aligned_box - box with axis-aligned edges with the given min and max coordinates Cylinder - an infinite cylinder FCylinder - a finite cylinder FractalLandscape- axis-aligned fractal landscape Light - represents lighting objects ParametricPlot - parametric plot routines Plane- an infinite plane Ring - an annulus of zero thickness Sphere- a sphere TachyonSmoothTriangle - a triangle along with a normal vector, which is used for smoothing TachyonTriangle - basic triangle class TachyonTriangleFactory - class to produce triangles of various rendering types Texfunc - creates a texture function Texture - stores texture information tostr() - converts vector information to a space-separated string 动画 我们知道动画是由一系列图形对象（或其他可迭代的对象）渲染生成的。通过对每个输入对象调用save_image方法，创建一系列PNG文件来生成图像。然后使用不同的工具将它们组合成各种目标格式。其中，ImageMagick的转换程序可用于生成动画GIF文件。FFmpeg（带有命令行程序FFmpeg）提供了对各种视频格式的支持，但也是生成动画GIF的另一种方法。对于支持APNG的浏览器，APNG可以用作另一种替代方案，并且无需任何额外的依赖。 例如： 使用ImageMagick生成动画 x = SR.var(\"x\") sines = [plot(c*sin(x), (-2*pi,2*pi), color=Color(c,0,0), ymin=-1, ymax=1) for c in sxrange(0,1,.2)] a = animate(sines) a # optional -- ImageMagick # Animation with 5 frames a.show() # optional -- ImageMagick 使用FFmpeg: f = tmp_filename(ext='.gif') a.save(filename=f, use_ffmpeg=True) # optional -- ffmpeg 生成APNG: a.apng() # long time 3D动画: Animations of 3d objects: s,t = SR.var(\"s,t\") def sphere_and_plane(x): return sphere((0,0,0),1,color='red',opacity=.5)+parametric_plot3d([t,x,s],(s,-1,1),(t,-1,1),color='green',opacity=.7) sp = animate([sphere_and_plane(x) for x in sxrange(-1,1,.3)]) sp[0] # first frame # Graphics3d Object sp[-1] # last frame # Graphics3d Object sp.show() # optional -- ImageMagick (x,y,z) = SR.var(\"x,y,z\") def frame(t): return implicit_plot3d((x^2 + y^2 + z^2), (x, -2, 2), (y, -2, 2), (z, -2, 2), plot_points=60, contour=[1,3,5], region=lambda x,y,z: x=t or z常用的绘图命令 plot()：当需要绘制基本的图形时，我们可以使用plot命令。 f(x) = sin(x) p = plot(f(x), (x, -pi/2, pi/2)) p.show() 默认情况下创建的绘图会非常简单，接下来我们可以通过增加一些配置绘图属性来进行装饰。比如添加轴标签axes_labels并使我们的绘制线color 为紫色： p = plot(f(x), (x,-pi/2, pi/2), axes_labels=['x','sin(x)'], color='purple') p.show() 其中，color选项可以接受多种形式，比如字符串颜色指定（'purple', 'green', 'red', 'black'等)）、RGB 三元组（如 （255，10，1）或 HTML 样式的十六进制三元组（如 #ff00aa）。 我们还可以通过使用 linestyle和 thickness选项更改线条的样式，比如实线、虚线以及粗细线： p = plot(f(x), (x,-pi/2, pi/2), linestyle='--', thickness=3) p.show() 那如果需要需要绘制多条线怎么办？我们可以通过将图直接“相加”来在同一轴上显示两个函数的图形。 f(x) = sin(x) g(x) = cos(x) p = plot(f(x),(x,-pi/2,pi/2), color='black') q = plot(g(x), (x,-pi/2, pi/2), color='red') r = p + q r.show() parametric_plot()：我们可以使用parametric_plot命令来处理参数图。比如画一个半径为 3 的简单圆。 t = var('t') sage: p = parametric_plot( [3*cos(t), 3*sin(t)], (t, 0, 2*pi) ) sage: p.show() polar_plot()：使用该命令polar_plot完成极坐标图。 sage: theta = var(\"theta\") sage: r(theta) = sin(4*theta) sage: p = polar_plot((r(theta)), (theta, 0, 2*pi) ) sage: p.show() plot3d()、implicit_plot3d()：生成 3D 绘图 var('x,y,z') g=golden_ratio;r =4.77 p = 2-(cos(x+g*y)+cos(x-g*y)+cos(y+g*z)+ cos(y-g*z)+cos(z-g*x)+cos(z+g*x)) show( implicit_plot3d(p,(x,-r,r),(y,-r,r),(z,-r,r),plot_points=30,color='orange',mesh=1,opacity=.7),spin=1, figsize=[8,16],dpi=300 ) var('x y z') F = (x^2+9/4*y^2+z^2-1)^3 - x^2*z^3 - 9/(80)*y^2*z^3 r = 1.5 show( implicit_plot3d(F, (x,-r,r), (y,-r,r), (z,-r,r),plot_points=30,color='red',mesh=0,opacity=.7),spin=1, figsize=[8,16],dpi=300 ) 优美案例 以上我们介绍了SageMath绘图的基础知识，那接下来让我们一起欣赏一些用SageMath绘制的比较有趣的图形，感受一下“函数之美”。 高斯函数 高斯函数是一种常用的数学函数，通常用来描述物理系统中的扩散过程。它的一般形式为： $$ f(x)=ae^{-(x-b)^2/{2c^2}} $$ 其中 a、b 与 c 为实数常数 ，且a > 0 高斯函数的图形在形状上像一个倒悬着的钟。参数a指高斯曲线的峰值，b为其对应的横坐标，c即标准差（有时也叫高斯RMS宽值），它控制着“钟”的宽度。 高斯函数在许多领域都有广泛应用，如信号处理、机器学习等。 我们只需要四行代码： a=var(\"x,a,b,c\") f(x,a,b,c)=a*e^(-(x-b)^2/(2*c^2)) p=plot(f(x,5,2,-0.5),(-10,10), ymin=-10, ymax=10) p.show() 接着我们通过控制参数并使用animate让高斯函数“动起来”，也只需要四行代码： sines = [plot(f(x,a,b,c), (-10,10), color=Color(c,0,0), ymin=-10, ymax=10) for a,b,c in zip(sxrange(1,10,1),sxrange(-10,10,2),sxrange(-1,0,0.1))] a = animate(sines) a.show() 笛卡尔心形函数 传说，当年52岁的笛卡尔邂逅了18岁的瑞典公主克里斯汀。笛卡尔在给克里斯汀寄出第十三封信后就气绝身亡了，这第十三封信内容只有短短的一个公式：r=a(1-sinθ）。 公主看到后，立即明了恋人的意图，她马上着手把方程的图形画出来，看到图形，她开心极了，她知道恋人仍然爱着她，原来方程的图形是一颗心的形状。这也就是着名的“心形线”。r=a(1-sinθ）是它在极坐标下的方程表达式： theta = var(\"theta\") a = 2 r(theta) = a*(1-sin(theta)) p = polar_plot((r(theta)), (theta, 0, 2*pi) ,color = 'red') p.show() 摆线的参数方程 摆线是指一个圆在一条定直线上滚动时，圆周上一个定点的轨迹，又称圆滚线、旋轮线。 摆线最早出现可见于公元 1501 年出版的 C·鲍威尔的一本书中。在17世纪，大批卓越的数学家（如伽利略，帕斯卡，托里拆利，笛卡儿，费尔马， 伍任，瓦里斯，惠更斯，约翰·伯努利，莱布尼兹，牛顿等等）热心于研究这一曲线的性质。17 世纪是人们对数学力学和数学运动学爱好的年代，这能解释人们为什么对摆线怀有强烈的兴趣。通常，摆线的参数方程可以表示为： $$ x = a*cos(ωt+φ) $$ $$ y = b*sin(ωt+φ) $$ 其中，a 和 b 是摆线的振幅，ω 是摆线的角速度，t 是时间，φ 是初始相位。 这个方程可以用来描述摆线的位置随时间的变化情况。通过改变 a、b、ω 和 φ 的值，可以得到不同的摆线运动轨迹。 t = var('t') a_values = [a for a in sxrange(0,10,1)] a_values.extend([a for a in sxrange(10,-10,-1)]) sines = [ parametric_plot( [a*t-sin(a*t), 1-cos(a*t)], (t, 0, 1) )+ implicit_plot((x-a)^2+(y-1)^2 == 1, (x,-12,12),(y,-1,3),color='red') for a in a_values] a = animate(sines) a.show() 绘制经典函数 x * sin(1/x) 我们在学高等数学的极限一章时应该对f(x)=x * sin(1/x)颇有印象。用SageMath来画一下，可以清楚的看到当x趋近于0时候，f(x)也将无限趋近于0。 p = plot(x * sin(1/x), x, -2, 2, plot_points=500) show(p) 玫瑰曲线方程 基本的极坐标玫瑰方程为： $$ ρ=a*cos(nθ) $$ t = var('t') n = 20/19 g1 = polar_plot(1+2*cos(n*t),(t,0,n*36*pi),plot_points=5000) g2 = polar_plot(1+1/3*cos(n*t),(t,0,n*36*pi),plot_points=5000) g1+g2 画两个3D圆锥体 x,y,z=var('x y z') Lx,Ly,Lz=12,12,12 def get_circular_cone(l=8,r=5,cl='red'): h=sqrt(l^2-r^2) r0=abs((z/h)*r) return implicit_plot3d( x^2+y^2==r0^2, (x,-Lx,Lx),(y,-Ly,Ly),(z,-Lz,Lz), plot_points=50,smooth=True, color=cl ) p0=get_circular_cone() show(p0) 转动的筷子曲线 puntos = [(0,0),(0,1),(1,3),(2,1)] K = len(puntos) var('x y') coefs = matrix(QQ, K, 6) for j in range(K): x0, y0 = puntos[j] coefs[j,:] = vector([x0^2, y0^2, x0*y0, x0, y0, 1]) K = coefs.right_kernel() v1 = K.basis()[0] v2 = K.basis()[1] graficas = [] for t in srange(0,2*pi,0.3): c1, c2 = sin(t), cos(t) a,b,c,d,e,f = c1*v1 + c2*v2 curva = a*x^2 + b*y^2 + c*x*y + d*x + e*y + f graficas.append( point2d(puntos,color=(1,0,0),pointsize=30) + implicit_plot(curva,(x,-1,4),(y,-1,4)) ) a = animate(graficas) a.show(delay=10) 画一只2D蝴蝶 def butterfly2d(): g = Graphics() x1, y1 = 0, 0 from math import sin, cos, exp, pi for theta in srange( 0, 10*pi, 0.01 ): r = exp(cos(theta)) - 2*cos(4*theta) + sin(theta/12)^5 x = r * cos(theta) y = r * sin(theta) xx = x*6 + 25 yy = y*6 + 25 if theta != 0: l = line( [(x1, y1), (xx, yy)], rgbcolor=hue(theta/7 + 4) ) g = g + l x1, y1 = xx, yy g.show(dpi=100, axes=False) butterfly2d() 画3D蝴蝶 def butterfly3d(): g = point3d((0,0,0)) x1, y1 = 0, 0 from math import sin, cos, exp, pi for theta in srange( 0, 10*pi, 0.05): r = exp(cos(theta)) - 2*cos(4*theta) + sin(theta/12)^5 x = r * cos(theta) y = r * sin(theta) xx = x*6 + 25 yy = y*6 + 25 if theta != 0: l = line3d( [(x1, y1, theta), (xx, yy, theta)], rgbcolor=hue(theta/7 + 4) ) g = g + l x1, y1 = xx, yy g.show(dpi=100, axes=False) butterfly3d() SageMath的帮助系统 Help帮助：使用 “？” 当我们需要准确了解某个函数或命令的作用以及如何使用它，我们可以使用 “？”来调用内置的帮助系统。例如： lcm? 查看源代码：使用“??” 有些喜欢研究源码的同学想看看 SageMath 中某个命令的源码，您只需键入您感兴趣的命令，然后键入“??”。 例如，查看factor()的源代码： factor?? 更多 受限于篇幅，我们以上只介绍了SageMath的小部分内容，其中提供的代码希望大家能够借助SmartNoteBook去亲自实践并查看输出的信息，探索和领悟SageMath和数学的魅力！ 如果您想了解更多关于SageMath的知识和用例，可以参考SDSU Sage Tutorial 以及SageMath Documentation "},"NoteBook/Julia.html":{"url":"NoteBook/Julia.html","title":"Julia语言","keywords":"","body":"Julia计算引擎 Julia语言是一种高性能的编程语言，专为数值和科学计算而设计。它于2012年发布，旨在结合C和Fortran的速度与Python和R的易用性。Julia支持并行和分布式计算，拥有丰富的数值函数库和优越的性能，特别适合大规模数据处理、机器学习、模拟和统计计算。其多重派发机制和强大的类型系统使得代码既高效又灵活。Julia语言在科学研究、金融分析、数据科学等领域日益受到青睐。 Julia计算引擎的安装配置 SmartNotebook默认的部署镜像内没有内置Julia计算引擎，需要Node环境中进行安装Julia和IJulia包。 1.安装Julia wget https://julialang-s3.julialang.org/bin/linux/x64/1.10/julia-1.10.4-linux-x86_64.tar.gz tar -xvf julia-1.10.4-linux-x86_64.tar.gz mv julia-1.10.4 /usr/lib/ PATH=$PATH:/usr/lib/julia-1.10.4/bin/ export PATH 2.安装IJulia：进入julia终端，按] 进入包管理模式，进入下面的命令 add IJulia 3.修改julia kernel 名称为统一为julia，smartnotebook默认为julia，而不是julia-1.10 mv /root/.local/share/jupyter/kernels/julia-1.10 /root/.local/share/jupyter/kernels/julia 4.查看kernel list： jupyter kernelspec list kernel list 参考信息如下： Available kernels: julia /root/.local/share/jupyter/kernels/julia-1.10 ir /usr/local/share/jupyter/kernels/ir python3 /usr/local/share/jupyter/kernels/python3 创建NoteBook 在新建NoteBook对话框中\"选择计算引擎(Kernel)类型\"为“Julia”的选项。 输入NoteBook标题并选择对应的环境，点击提交完成创建。 [!warning|style:flat] 成功创建NoteBook后，用户无法在不同的kernel语言类型之间切换。 SNB对其他Julia内核的支持仍处于早期阶段，有些功能尚不完善，例如变量资源管理器、SQL单元格、模型视图及低代码插件不支持。 当前支持的功能 MarkDown 单元格 收藏 评论 资源和文件管理 大纲目录 环境及调度任务 版本管理 代码仓库 单元格的状态 代码格式 单元格代码补全 团队协作编辑 终端 快捷键支持 Hello Julia 示例 println(\"Welcome to Julia world of SmartNoteBook \\n\") Julia的探索 下面是基本5段Julia语言代码示例，分别涵盖基本操作、数据集操作、统计分析、可视化和机器学习。以下是代码示例： 1.基本操作 # 基本数学运算 a = 10 b = 5 sum = a + b difference = a - b product = a * b quotient = a / b println(\"Sum: $sum, Difference: $difference, Product: $product, Quotient: $quotient\") # 创建数组 arr = [1, 2, 3, 4, 5] println(\"Array: \", arr) # 循环与条件语句 for i in arr if i % 2 == 0 println(\"$i is even\") else println(\"$i is odd\") end end 2.数据处理 using DataFrames # 创建 DataFrame data = DataFrame(Name = [\"Alice\", \"Bob\", \"Charlie\"], Age = [25, 30, 35], Salary = [50000, 60000, 70000]) println(\"DataFrame:\") println(data) # 过滤数据 filtered_data = filter(row -> row[:Age] > 28, data) println(\"\\nFiltered DataFrame (Age > 28):\") println(filtered_data) 3.可视化 using Plots # 基本绘图 x = 1:10 y = rand(10) # 散点图 scatter(x, y, title = \"Random Scatter Plot\", xlabel = \"X-axis\", ylabel = \"Y-axis\") # 折线图 y2 = rand(10) plot(x, y2, title = \"Random Line Plot\", xlabel = \"X-axis\", ylabel = \"Y-axis\", label = \"Line 1\") # 组合图 plot!(x, y, seriestype = :scatter, label = \"Scatter 1\") 4.安装包示例 using Pkg Pkg.add(\"DataFrames\") Pkg.add(\"Plots\") "},"NoteBook/AIGC.html":{"url":"NoteBook/AIGC.html","title":"AI助手(数据智灵)","keywords":"","body":"数据智灵(AI伴侣) \"数据智灵\"是一个集成了一系列强大的人工智能驱动功能的工具，专为代码生成和编辑设计。不论您是需要生成Python或SQL代码，还是需要编辑和修复已有的代码，\"数据智灵\"都能够根据您的自然语言需求提供相应的帮助。 更重要的是，\"数据智灵\"能够生成详细的代码描述，这对于理解代码的功能和运行机制具有极大的帮助。不论您的编程经验如何，无论是初学者还是资深开发者，\"数据智灵\"都能有效地协助您完成各类代码任务，提高编程效率和准确性。 [!warning|style:flat] \"数据智灵\"目前仍处于公开测试阶段，所以可能存在一些小问题和不完善。该功能属于实验性质，您不应该过分依赖人工智能生成的代码的准确性、完整性或无偏性。\"数据智灵\"的设计初衷是为了提升人类的洞察力和判断力，而非取代它们。因此在使用过程中仍然需要您，作为用户，点击运行按钮。\"数据智灵\"不会自动运行由AI生成的代码，因此判断所生成代码的正确性完全取决于您。在使用的过程中，请您始终保持谨慎，并结合自身的专业知识和判断力进行决策。 如何使用？ 新建Python或SQL单元格，然后单击单元格中的文字链接使用数据智灵...或单击单元格右上角的数据智灵按钮 开始使用。 生成代码 单击单元格中的文字链接使用数据智灵...或单击单元格右上角的数据智灵按钮 并选择生成代码，然后在Prompt输入框中用通俗易懂的语言尽可能具体的描述你想要生成的代码内容，输入完成后，点击回车键。 生成完成后，您可以点击应用或应用并执行来使用新代码，也可以点击丢弃代码。 例如：帮我用pyecharts生成一个折线图的例子，渲染到NoteBook。 编辑​代码 单击单元格左上角的Generate切换至Edit或单击单元格右上角的数据智灵按钮 并选择编辑代码，然后在Prompt输入框中用通俗易懂的语言尽可能具体的描述你想要修改的代码内容，输入完成后，点击回车键。 数据智灵生成完成后，您可以点击应用或应用并执行来使用新代码，也可以点击丢弃代码。 例如：筛选Sex为male的数据。 调试/修复​ 当一个单元格返回错误时，您可以点击报错信息下方的 或单击单元格右上角的数据智灵按钮 并选择调试/修复​，数据智灵就会开始修复代码。 数据智灵生成修复后的代码完成后，您可以点击应用或应用并执行来使用新代码，也可以点击丢弃代码。 例如： 生成注释 单击单元格右上角的数据智灵按钮 并选择生成注释。 数据智灵生成注释完成后，您可以点击应用或应用并执行来使用新代码，也可以点击丢弃代码。 数据隐私​ SNB非常重视您的数据隐私： 客户数据保护：我们深知客户数据的价值和敏感性，数据智灵坚决不会将客户数据用于训练模型。所有数据在处理过程中都将被严格保密，我们不会无授权地使用、共享或出售您的数据。 第三方服务使用：虽然数据智灵的一部分功能依赖于第三方服务（例如OpenAI），但我们保证所有通过第三方服务处理的数据都将符合严格的隐私保护标准。我们与第三方服务提供商的协议明确规定，他们无权使用、访问或保存您的任何数据。 数据加密：为了进一步保护您的数据，所有存储在数据智灵的数据都将进行安全的加密处理，无论数据在传输还是存储过程中，都将受到最高级别的保护。 用户控制权：您对自己的数据有完全的控制权，可以随时查看、修改或删除您的数据。如果您有任何疑问或需要支持，我们的客户服务团队将随时为您提供帮助。 法规遵从：数据智灵严格遵守所有适用的数据保护法规，我们坚决致力于保护客户的数据隐私权益。 Python示例 插入Python单元格 打开数据智灵(AI伴侣)，两种方式打开数据智灵，空单元内快速进入模式(使用数据智灵....)或单元格内智灵图标打开。 Prompt输入框输入:使用pandas加载本地iris.csv文件，数据集名称为df. 然后回车提交,思考中... 生成的代码后，确认返回代码：然后我们点击应用代码 接受生成的代码，并执行 接下来依次操作,完成聚类分析: 将 数值的四个字段进行降维度，降到2维，合并df数据集上，分别为x、y 列将使用seaborn以Species为系列，分别以x,y为x、y轴生成散点图 整个操作过程： SQL示例 插入SQL 单元格 选择数据源(生成SQL会依赖部分的元数据：表结构,所以先设定数据源,作为生成SQL的上下文信息) 打开数据智灵，输入需求描述：查询表,并计算学生的总分 引用表的元数据,生成SQL 应用并执行,得到需要的数据 整个操作过程： "},"NoteBook/Sidebar.html":{"url":"NoteBook/Sidebar.html","title":"互动分享与导航","keywords":"","body":"侧边栏 侧边栏为NoteBook提供一系列扩展功能。 功能概览 图标 功能 解释 数据资源 文件和数据库管理 计算环境 查看和管理当前NoteBook的计算资源和调度器 导航目录 NoteBook根据Markdown单元格中使用的标题显示文档结构 变量预览 浏览NoteBook中使用的变量、值和值的一些属性 版本列表 保存NoteBook版本并可还原至历史记录的状态 软件包 NoteBook的包管理 代码片段库 包含公有库（NoteBook提供的常用代码片段）和我的收藏（用户收藏的代码片段）。 快捷键 快捷键包含notebook编辑模式、命令模式、文档级别（全局Global） Packages 默认情况下，NoteBook的运行环境已经为用户安装了常用的数据分析、机器学习以及可视化的包。 搜索并查看包版本 安装/升级包 在安装的Tab页搜索要安装的包名称 点击放大镜或敲击回车进行搜索 在结果列表找到需要安装/升级的包和版本号，点击右侧的下载图标开始安装 删除包 在已安装的Tab页搜索要删除的包名称 在结果列表找到需要删除的包和版本号，点击右侧的删除图标 数据资源 集成和管理用户的数据资产，显示包括已建立的数据连接（数据库）和已上传的数据文件（csv/excel/txt/json等）。 上传文件 * 通过NoteBook的数据资源同步，可以根据需要将MinIO公共区域的资源文件同步至Node节点使用 ![](/assets/身教重于言教.png)--> 数据连接 复制连接 已建立的数据库连接将显示在数据资源板块中，可点击复制数据连接按钮，将数据连接代码拷贝至单元格使用。（新建数据连接以及当前支持的数据源类型请参考前面的教程数据源） 浏览元数据 点击数据库右侧按钮查看库表元数据。 元数据浏览（如元数据有更新，可点击上方刷新按钮重新获取） 复制数据源到MindsDB 复制代码至SQL单元格执行，能够快捷无缝的将数据源引入到MindsDB。 MindsDB结合NoteBook的使用教程可以参考MindsDB(SQL+ML)实战案例 WorkSpace文件 查看和同步文件 点击右侧小箭头查看已上传至WorkSpace的文件 批量同步至Node环境：点击文件一键同步到Node按钮可将文件批量同步至环境文件 单个文件同步至Node环境：如需同步单个文件，则点击该文件右侧的操作按钮，单击同步到Node即可 下载文件 点击文件列表右侧下载按钮可将文件下载至本地 环境文件 查看文件：点击右侧小箭头查看当前环境下的文件 文件上传：直接上传文件至环境下 刷新：刷新文件列表 复制路径：点击复制按钮可拷贝文件路径 下载文件：点击文件列表右侧下载按钮可将文件下载至本地 删除文件：将文件从环境下删除 文件预览（可编辑内容并保存） 点击环境文件下的csv数据文件（蓝色），可以像操作Excel表格一样对数据进行预览和编辑（编辑内容后记得点击保存）。 [!WARNING] 目前NoteBook仅支持csv数据文件的预览，且文件大小不超过10M 目录 目录是一种工具，它根据MarkDown单元格中当前使用的标题显示NoteBook的结构。 MarkDown使用\"#\"表示不同级别的标题，例如： \"# 一级标题\" \"## 二级标题\" \"### 三级标题\" NoteBook采集MarkDown的标题层级配合层次缩进自动生成目录 同时，目录是交互式的：单击标题可导航到NoteBook中的相应部分 环境 查看配置/负载情况 切换环境 当用户购买和构建了多个环境资源，可根据需要切换NoteBook的运行环境 当前环境信息 在NoteBook的底部状态栏中，您可以看到当前环境的基本配置以及实时的使用状态。 [!NOTE|style:flat] 环境名称旁边的小圆点通过颜色来直观表示环境的运行状况：蓝色表示环境状态正常，而红色则表示出现异常。 创建调度器 创建调度器的方法详见WorkSpace调度器 变量浏览 浏览NoteBook中使用的变量、值和值的一些属性。 单元格的代码执行后，变量将出现在左侧的变量浏览列表中，其中包含有关其类型和内容的信息，如变量名、变量的值、变量类型、占用大小等。 变量预览和编辑 点击变量列表中的DataFrame数据变量（蓝色），可以像操作Excel表格一样对变量进行预览和编辑（编辑内容后记得点击保存）。 [!WARNING] 该手动编辑变量的操作不会被SNB记录，因此重新执行NoteBook该手动操作无法重现。 [!warning|style:flat] 重启Kernel的操作将会清除所有已存储的变量值。如果用户在某些变量中保存了非常重要的数据，请在重启Kernel前将重要变量的数据保留下来。 版本列表 保存版本 NoteBook文档在我们编写期间会每隔30秒保存一次内容，但如果需要永久保存NoteBook某一个时点的内容和状态，用户需要自行保存成版本。初始状态下版本列表是空的： 按下Ctrl + S，输入版本名称和版本信息后点击确定按钮，提示版本保存成功。 如用户在WorkSpace设置里配置了代码仓库GitLab或GitHub，保存版本可选择推送至代码仓库。 版本列表会增加已推送至代码仓库标识： 保存新版本时查看最近保存版本的信息： 版本对比 单击列表中某个版本，可打开该历史版本与当前NoteBook内容进行对比。 下图左侧为历史版本内容，右侧为当前NoteBook文档的内容 回退版本 点击版本列表右侧的回退按钮，可以将当前NoteBook文档内容恢复至历史版本 代码片段 公有库 SmartNoteBook帮用户内置了一些常用的代码片段，用户根据需要复制使用 鼠标移动到代码片段右侧会显示预览框，点击代码名称右侧的复制按钮可复制整块代码 我的收藏 个人收藏的代码片段，用户根据需要复制使用 同样的，鼠标移动到代码片段右侧会显示预览框 代码名称右侧两个按钮分别为删除代码块和复制整块代码 收藏代码的操作详见代码收藏 "},"NoteBook/Toolbar.html":{"url":"NoteBook/Toolbar.html","title":"工具栏","keywords":"","body":"工具栏 工具栏提供对NoteBook的一系列扩展操作 功能概览 主菜单 二级菜单 功能介绍 文件 最近打开的 查看最近编辑过的NoteBook文档（点击可在新的标签页打开） 分享 功能同NoteBook右上角的`分享` 按钮，分享的操作详见分享 重命名 点击修改NoteBook上方的文件名 导出.ipynb 导出snb格式文件（SmartNoteBook专用格式） 导出.snb 导出.ipynb文件(兼容Jupyter NoteBook) 保存 手动保存NoteBook（除此之外提供每30s自动保存） 工具 保存版本 保存NoteBook版本，该功能参见侧边栏的版本列表-->保存版本 数据资源 打开`数据资源`，该功能参见侧边栏的数据资源 计算环境 打开`计算环境`，该功能参见侧边栏的计算环境 导航目录 打开`导航目录`，该功能参见侧边栏的导航目录 变量预览 打开`变量预览`，该功能参见侧边栏的变量预览 版本列表 打开`版本列表`，该功能参见侧边栏的版本列表 软件包 打开`软件包`，该功能参见侧边栏的软件包 代码片段库 打开`代码片段库`，该功能参见侧边栏的代码片段库 终端 打开命令行界面与服务器交互 模型视图 分析代码中的变量关系生成关系图模型视图 CELL宽度 设置notebook页面，cell单元格的宽度窄、中和宽三种 Kernel 中断Kernel 中断运行正在运行的代码 重启Kernel 重新启动Kernel（例如某些package安装后需要重启） 运行 全部运行 运行NoteBook下所有的单元格（按照Sheet顺序） 运行当前及上方所有单元格 运行选中的单元格及之前所有单元格的代码（当前Sheet内） 运行当前及下方所有单元格 运行选中的单元格及之后所有单元格的代码（当前Sheet内） 运行当前sheet的所有单元格 运行当前sheet的所有单元格 清除全部输出 清除NoteBook中所有单元格的输出（全部Sheet） 隐藏全部输入 分享时隐藏NoteBook中所有单元格的输入（全部Sheet） 帮助 快捷键 详见快捷键 帮助手册 打开帮助手册 终端 用户通过终端连接至容器，使用bash命令查看和操作服务器的资源（慎用）。 模型视图 分析代码中的变量关系生成关系图，直观展示NoteBook的整体分析脉络以及单元格间的相互关系。 可解释性：容易看到各单元格如何相互关联，查看整个NoteBook代码逻辑的“流动”，是跟踪复杂逻辑的可视化“思维导图”。 性能：在模型开发过程中，这种DAG模型几乎不会产生额外的性能开销，对性能无任何影响。 交互方面： 点击模型视图中的代码框可以快速定位到左侧的单元格 代码框右下角的图标可识别代码类型 线条箭头的指向代表了代码逻辑的流向，线条中间为上下关联的变量 模型视图中的代码框可以任意拖动 右上角支持打开/关闭小地图。小地图显示模型视图的预览，并且支持鼠标在小地图拖动控制显示的区域（对于模型视图显示面积过大的情况会很有帮助） Kernel Kernel是一个独立于NoteBook的进程，它运行用户编写的代码并处理NoteBook中的输入和输出。Kernel会将代码执行的结果返回给NoteBook，然后NoteBook会将结果渲染成适当的格式并显示出来，可以理解为是NoteBook和代码之间的中间层。 Kernel可以支持多种编程语言，包括Python、R、Julia等，用户可以根据需要选择不同的Kernel来运行不同的代码（参考新建NoteBook时选择Kernel） 。 中断Kernel 中断Kernel是指中断kernel正在运行的代码，针对NoteBook内正在运行的单元格和待运行的单元格。 重启Kernel 当环境发生变化（如环境安装了新的包或其他情况），需要重启Kernel时使用。 [!warning|style:flat] 重启Kernel的操作将会清除所有已存储的变量值。如果用户在某些变量中保存了非常重要的数据，请在重启Kernel前将重要变量的数据保留下来。 "},"NoteBook/Graph.html":{"url":"NoteBook/Graph.html","title":"模型视图","keywords":"","body":"模型视图 模型视图显示了SmartNoteBook项目中Notebook中单元格之间的关系。 [!warning|style:flat] 您可以将模型视图视为逻辑的视觉镜像。您对 Notebook 视图中的单元格所做的任何更改都将反映在 Graph 视图中。 您选择模型视图中特定的节点，我们会在模型视图中突出显示上游祖先节点和下游后代节点，并在NoteBook视图中自动滚动到该单元格。这对于特别长或复杂的项目非常有用，因为在这些项目中很难看到单元格之间的依赖关系。 为了优化图形视图的可读性，可以使用不同的方法来组织图形视图中的元素。您可以通过将单元格拖放到图形视图中的任意位置来重新排列它们。还有鼠标操作，您可以使用它们来放大、缩小或缩放以适应宽度。可以通过拖动图形视图和逻辑之间的边框来调整此宽度。 您可以调整小地图是否显示。 示例 变量引用被自动推断为链接（或“边”），并以可视化布局显示，如下例所示： Your browser does not support the video tag. "},"NoteBook/Collections.html":{"url":"NoteBook/Collections.html","title":"收藏","keywords":"","body":"代码收藏 收藏代码 收藏单元格代码至代码片段仓库，以供复用或其他团队成员参考使用。 点击单元格右侧的 按钮。 选择代码目录（可在此页面创建新的目录），填写代码段名称和说明后，点击收藏 [!Tip] 下方代码预览区域用户可对代码编辑和修改。 使用代码 收藏后的代码保存在侧边栏的代码片段--> 我的收藏-->用户自己创建的目录下。 鼠标移至代码段列表上方将显示全部代码的预览界面。 可以点击代码片段右侧的操作按钮进行代码复制和删除。 "},"NoteBook/Comments.html":{"url":"NoteBook/Comments.html","title":"评论","keywords":"","body":"评论 团队成员在单元格上开展实时评论和协作，促进成员间的交流和合作，加速问题解决、知识分享和代码质量改进。 发表评论 点击单元格右侧的 按钮。 点击发送或回车： [!Tip] 评论按钮颜色 会提示你在哪个单元格上有小伙伴发表了评论。 删除评论 用户可以删除自己发表的评论，鼠标移动到评论的右上角时可以进行删除 "},"NoteBook/Share.html":{"url":"NoteBook/Share.html","title":"分享","keywords":"","body":"分享 NoteBook有很好的代码展示性，可作为“项目报告”承载研究成果，并能够以网页的形式进行分享。 在分享的内容方面，既可以整体分享NoteBook（包含所有Cell代码块的输入输出），也可单独分享某个Cell代码块的输出。 分享整个NoteBook 第一种方式：点击NoteBook右上角的分享按钮 复制分享链接： 将分享链接贴入浏览器中查看分享报告： 第二种方式：点击文件菜单下的分享按钮： 分享报告时隐藏输入/输出 控制单个单元格输入/输出的显隐： 批量隐藏（适用于生成报告时批量隐藏代码输入）： 分享单元格的输出 用户只需要分享某个单元格的输出时，可以点击单元格右侧的 按钮。 获得分享链接： 打开链接查看分享的内容： "},"NoteBook/Shortcuts.html":{"url":"NoteBook/Shortcuts.html","title":"快捷键","keywords":"","body":"快捷键 为配合用户使用习惯，SmartNoteBook参考了很多Jupyter的快捷键。 此外，SmartNoteBook为改进用户体验，也增加了很多自定义的快捷键，满足全局模式下以及不同模式不同单元格状态下的快捷操作。 编辑模式和命令模式 编辑状态：单元格左侧显示绿色。此时焦点处于代码输入框中，输入框处于编辑状态。用于书写代码或配置低代码组件参数。 命令状态：单元格左侧显示蓝色。当前单元格处于选定状态，但焦点不位于输入框。用于单元格间的操作，比如利用快捷键快速插入新单元格。 状态的切换 当使用鼠标点击单元格输入框的代码编辑区域时，单元格的选中状态变为编辑状态，除此之外，当点击单元格的其他区域单元格的选中状态都为命令状态。 除使用鼠标点击来切换单元格的选中状态，也可以使用快捷键进行切换： Enter 回车：命令状态 --> 编辑状态 ESC 取消：编辑状态 --> 命令状态 全局快捷键 文档级 Ctrl+S | ⌘S：版本保存 代码单元格状态 Enter：命令状态 --转化为-->编辑状态 ESC：编辑状态--转化为-->命令状态 代码单元格运行 Ctrl+Enter | ⌘Enter：运行当前单元格 Shift+Enter | ⇧Enter：运行当前单元格，并选定下面一个单元格 Alt+Enter | ⌥Enter：运行当前单元格，并下面插入一个code类型单元格(code cell) [!NOTE] 全局快捷键即无论处于命令模式还是编辑模式下都可正常使用。 命令模式下支持的快捷键 代码单元格操作注：\"命令状态\" 才有效 D+D：删除当前单元格 A：在当前单元格前插入单元格 B：在当前单元格后插入单元格 C：复制选中单元格 X: 剪切选中单元格 V: 粘贴单元格 编辑模式下支持的快捷键 代码单元格（编辑器）的快捷键 macOS版本 快捷键 功能说明 ⌘X 剪切所选内容，若无选中区域，则剪切光标所在行 ⌘C 复制所选内容，若无选中区域，则复制光标所在行 ⌘V 粘贴剪切板内容 ⌘A 全选当前单元格中的内容 ⌘Z 撤销上一步操作 ⌘⇧Z 恢复上一次撤销的操作 ⇧⌥↓ / ⇧⌥↑ 在下面/在下面复制当前行 ⇧⌘K 删除当前行 ⇧⌘Enter 在上面插入一个新的空白行 ⌘] / ⌘[ 缩进/取消缩进当前行 Fn← / Fn→ 定位到这一行的开头/末尾 ⌘↑ / ⌘↓ 定位到单元格的开头/末尾 ⌘Fn↓ / ⌘Fn↑ 在单元格中向下/向上滚动（以便查看单元格中的内容） 先⌘K 后⌘[ / 先⌘K 后⌘] 折叠/展开代码的所有子区域 先⌘K 后⌘0 / 先⌘K 后⌘J 折叠/展开代码的所有区域 先⌘K 后⌘C 添加行注释 先⌘K 后⌘U 取消行注释 ⌘/ 添加/取消行注释（切换行注释） ⇧⌥A 添加/取消块注释（在python语言的单元格中，则是添加三引号\"\"\" \"\"\"） ⌥⌘↑ 在上面一行添加光标 ⌥⌘↓ 在下面一行添加光标 ⌘U 撤销上一步的光标操作 ⇧⌥I 光标插入到选中区域的末尾 ⌥↑ / ⌥↓ 将当前行向上/向下移动 ⌥← / ⌥→ 向左/向右移动光标（以单词为单位） ⌘L 选择当前行 ⇧⌘L 选择当前所选内容的所有引用 ⌘F2 选择当前词的所有引用 ⌃⇧⌘→ / ⌃⇧⌘← 扩大/缩小选择范围 ⌘F 查找 ⌥⌘F 替换 ⌘G / ⇧⌘G 向后/向前查找 ⌘D 将所选内容添加到下一个“查找匹配项”，并插入光标 先⌘K 后⌘D 将上一个的选择内容移动到下一个“查找匹配项” 先⌘K 后⌘X 去掉行末尾的空格 ⌘I 触发语法提示 ⇧Tab 打开当前函数/变量的使用帮助 ⌃G 定位到指定行 Windows版本 快捷键 功能说明 Ctrl+X 剪切所选内容，若无选中区域，则剪切光标所在行 Ctrl+C 复制所选内容，若无选中区域，则复制光标所在行 Ctrl+V 粘贴剪切板内容 Ctrl+A 全选当前单元格中的内容 Ctrl+Z 撤销上一步操作 Ctrl+Shift+Z 恢复上一次撤销的操作 Shift+Alt+↓ / Shift+Alt+↑ 在下面/在下面复制当前行 Ctrl+Shift+K 删除当前行 Ctrl+Shift+Enter 在上面插入一个新的空白行 Ctrl+] / Ctrl+[ 缩进/取消缩进当前行 Home / End 定位到这一行的开头/末尾 Ctrl+Home / Ctrl+End 定位到单元格的开头/末尾 Ctrl+PgUp / Ctrl+PgDn 在单元格中向下/向上滚动（以便查看单元格中的内容） 先Ctrl+K，后Ctrl+[ / 先Ctrl+K，后Ctrl+] 折叠/展开代码的所有子区域 先Ctrl+K，后Ctrl+0 / 先Ctrl+K，后Ctrl+J 折叠/展开代码的所有区域 先Ctrl+K，后Ctrl+C 添加行注释 先Ctrl+K，后Ctrl+U 取消行注释 Ctrl+/ 添加/取消行注释（切换行注释） Shift+Alt+A 添加/取消块注释（在python语言的单元格中，则是添加三引号\"\"\" \"\"\"） Alt+Ctrl+↑ 在上面一行添加光标 Alt+Ctrl+↓ 在下面一行添加光标 Ctrl+U 撤销上一步的光标操作 Shift+Alt+I 光标插入到选中区域的末尾 Alt+↑ / Alt+↓ 将当前行向上/向下移动 Alt+← / Alt+→ 向左/向右移动光标（以单词为单位） Ctrl+L 选择当前行 Shift+Ctrl+L 选择当前所选内容的所有引用 Ctrl+F2 选择当前词的所有引用 Shift+Alt+→ / Shift+Alt+← 扩大/缩小选择范围 Ctrl+F 查找 Ctrl+H 替换 F3 / Shift+F3 向后/向前查找 Ctrl+D 将所选内容添加到下一个“查找匹配项”，并插入光标 先Ctrl+K，后Ctrl+D 将上一个的选择内容移动到下一个“查找匹配项” 先Ctrl+K，后Ctrl+X 去掉行末尾的空格 Ctrl+I 触发语法提示 Shift+Tab 打开当前函数/变量的使用帮助 Ctrl+G 定位到指定行 MarkDown单元格支持的快捷键 macOS版本 快捷键 功能说明 ⌘Z 撤销 ⌘Y 重做 ⌘X 剪切 ⌘C 复制 ⌘V 粘贴 ⌘A 全选 ⌘← 跳转到句首 ⌘→ 跳转到句尾 ⌘↑ 跳转到文档开头 ⌘↓ 跳转到文档末尾 ⌘1/⌘2/⌘3/⌘4/⌘5/⌘6 一级/二级/三级/四级/五级/六级标题 Tab 缩进 ⇧Tab 取消缩进 ⌘D 删除选中行 ⌘+delete 清空所有内容 ⌘B 加粗 ⌘I 斜体 ⌘H # 标题 ⌘U ++下划线++ ⌘M ==标记== ⌘L 链接标题 ⌘⌥S ^上角标^ ⌘O 有序列表 ⌘⌥U - 无序列表 ⌘⌥C ``` 代码块 ⌘⌥L 插入图片 ⌘⌥T 表格 ⌘⇧S 下角标 ⌘⇧D 中划线 ⌘⇧C 居中对齐 ⌘⇧L 居左对齐 ⌘⇧R 居右对齐 Windows版本 快捷键 功能说明 Ctrl+Z 撤销 Ctrl+Y 重做 Ctrl+X 剪切 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+A 全选 Home 跳转到句首 Ctrl+Home 跳转到文档开头 End 跳转到句尾 Ctrl+End 跳转到文档末尾 Ctrl+1/2/3/4/5/6 对应六级标题 Tab 缩进 Shift + Tab 取消缩进 Ctrl+D 删除选中行 Ctrl+BreakSpace 清空所有内容 Ctrl+B 加粗 Ctrl+I 斜体 Ctrl+H # 标题 Ctrl+U ++下划线++ Ctrl+M ==标记== Ctrl+Q > 引用 Ctrl+L 链接标题 Ctrl+Alt+S ^上角标^ Ctrl+O 有序列表 Ctrl+Alt+U - 无序列表 Ctrl+Alt+C ``` 代码块 Ctrl+Alt+L 插入图片 Ctrl+Alt+T 表格 Ctrl+Shift+S 下角标 Ctrl+Shift+D 中划线 Ctrl+Shift+C 居中对齐 Ctrl+Shift+L 居左对齐 Ctrl+Shift+R 居右对齐 "},"Tutorial/main.html":{"url":"Tutorial/main.html","title":"数据分析案例","keywords":"","body":"分析案例 以一些数据分析案例开启SmartNoteBook的探索之旅吧！ "},"Tutorial/Register.html":{"url":"Tutorial/Register.html","title":"申请账号","keywords":"","body":"申请账号 我们首先访问SmartNoteBook的地址 点击右上角的创建账号，填写我们的邮箱和登录密码。 账号申请成功后，后台会发送邮件至我们的邮箱，我们需要通过邮件内的链接来完成注册。 收到的邮件如下图所示： 然后我们回到SmartNoteBook的地址，输入刚刚申请的邮箱及密码，点击登录。 如果成功跳转到WorkSpace页面，表示账号申请成功，如未成功登录请联系管理员。 "},"Tutorial/YourFirstML.html":{"url":"Tutorial/YourFirstML.html","title":"机器学习","keywords":"","body":"机器学习案例 我们以一个经典的鸢尾花分类实验带大家熟悉NoteBook的使用。 Iris数据集是常用的分类实验数据集，由Fisher, 1936收集整理。Iris也称鸢尾花卉数据集，是一类多重变量分析的数据集。 数据集包含150个数据样本，分为3类，每类50个数据，每个数据包含4个属性。可通过花萼长度，花萼宽度，花瓣长度，花瓣宽度4个属性预测鸢尾花卉属于（Setosa，Versicolour，Virginica）三个种类中的哪一类。 数据导入和准备 添加代码块 我们先添加一个Python代码块Cell。 导入数据 输入以下代码，引入我们所需的库，并读取数据文件。 import numpy as np import pandas as pd dataset = pd.read_csv('../Iris.csv') 数据集概览 先快速了解一下数据集包含多少记录（行）和多少属性（列） dataset.shape 预览一下前五条记录 dataset.head(5) 数据集整体的描述 dataset.describe() 属于每个种类的记录（行）数。 dataset.groupby('Species').size() 划分数据集 如我们所见，数据集包含六列： Id 序号 SepalLengthCm （花萼长度），单位：cm SepalWidthCm（花萼宽度），单位：cm PetalLengthCmd（花瓣长度），单位：cm PetalWidthCmd（花瓣宽度），单位：cm Species 种类 实际特征由第1-4列描述。最后一列包含样本标签。首先，我们需要将数据分成两个数组：X（特征）和y（标签）。 feature_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm','PetalWidthCm'] X = dataset[feature_columns].values y = dataset['Species'].values 标签转成编码 由于标签是文本类型。而KNeighborsClassifier不接受字符串标签。因此我们需要使用LabelEncoder将它们转换为数字。setosa鸢尾对应0，versicolor鸢尾对应1，virginica鸢尾对应2。 from sklearn.preprocessing import LabelEncoder le = LabelEncoder() y = le.fit_transform(y) 数据集拆分 我们将数据集拆分为训练集和测试集，以便稍后检查分类器是否正确工作。 from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0) 数据可视化 引入所需的包 import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline 平行坐标图 平行坐标图是可视化高维多元数据的一种常用方法，为了显示多维空间中的一组对象，绘制由多条平行且等距分布的轴，并将多维空间中的对象在平行坐标图中用一条折线表示，纵向是属性值，横向是属性类别，为了反映变化趋势和各个变量间相互关系，往往将描述不同变量的各点连接成折线。 from pandas.plotting import parallel_coordinates plt.figure(figsize=(15,10)) parallel_coordinates(dataset.drop(\"Id\", axis=1), \"Species\") plt.title('Parallel Coordinates Plot', fontsize=20, fontweight='bold') plt.xlabel('Features', fontsize=15) plt.ylabel('Features values', fontsize=15) plt.legend(loc=1, prop={'size': 15}, frameon=True,shadow=True, facecolor=\"white\", edgecolor=\"black\") plt.show() 安德鲁斯曲线 安德鲁斯曲线允许人们用大量的曲线来绘制多元数据 (multivariate data)，这些曲线使用样本属性作傅立叶级数的系数来创建，通过为每个群不同的曲线着色，可以可视化数据聚类。属于同一群样本的曲线通常会比较接近，形成较大的结构。 from pandas.plotting import andrews_curves plt.figure(figsize=(15,10)) andrews_curves(dataset.drop(\"Id\", axis=1), \"Species\") plt.title('Andrews Curves Plot', fontsize=20, fontweight='bold') plt.legend(loc=1, prop={'size': 15}, frameon=True,shadow=True, facecolor=\"white\", edgecolor=\"black\") plt.show() 两两关系图Pairplot Pairplot主要展现的是变量两两之间的关系（线性或非线性，有无较为明显的相关关系） plt.figure() sns.pairplot(dataset.drop(\"Id\", axis=1), hue = \"Species\", height=3, markers=[\"o\", \"s\", \"D\"]) plt.show() 可视化3D图 from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(1, figsize=(20, 15)) ax = Axes3D(fig, elev=48, azim=134) ax.scatter(X[:, 0], X[:, 1], X[:, 2], c=y, cmap=plt.cm.Set1, edgecolor='k', s = X[:, 3]*50) for name, label in [('Virginica', 0), ('Setosa', 1), ('Versicolour', 2)]: ax.text3D(X[y == label, 0].mean(), X[y == label, 1].mean(), X[y == label, 2].mean(), name, horizontalalignment='center', bbox=dict(alpha=.5, edgecolor='w', facecolor='w'),size=25) ax.set_title(\"3D visualization\", fontsize=40) ax.set_xlabel(\"Sepal Length [cm]\", fontsize=25) ax.w_xaxis.set_ticklabels([]) ax.set_ylabel(\"Sepal Width [cm]\", fontsize=25) ax.w_yaxis.set_ticklabels([]) ax.set_zlabel(\"Petal Length [cm]\", fontsize=25) ax.w_zaxis.set_ticklabels([]) plt.show() 使用KNN进行分类 预测 from sklearn.neighbors import KNeighborsClassifier from sklearn.metrics import confusion_matrix, accuracy_score from sklearn.model_selection import cross_val_score classifier = KNeighborsClassifier(n_neighbors=3) classifier.fit(X_train, y_train) y_pred = classifier.predict(X_test) y_pred 评估 混淆矩阵 cm = confusion_matrix(y_test, y_pred) cm​ 评估模型预测的准确率 accuracy = accuracy_score(y_test, y_pred)*100 print('模型准确率： ' + str(round(accuracy, 2)) + ' %.') 使用交叉验证进行参数调整 k_list = list(range(1,50,2)) cv_scores = [] for k in k_list: knn = KNeighborsClassifier(n_neighbors=k) scores = cross_val_score(knn, X_train, y_train, cv=10, scoring='accuracy') cv_scores.append(scores.mean()) MSE = [1 - x for x in cv_scores] xvalues=[str(x) for x in k_list] line=Line() line.add_xaxis(xvalues) line.add_yaxis('', MSE,is_smooth=False,label_opts=opts.LabelOpts(is_show=True),symbol='none') line.set_global_opts(title_opts=opts.TitleOpts(title=\"最佳邻居数\"), yaxis_opts=opts.AxisOpts( min_=0.040,name=\"分类错误\",name_location = 'center',name_gap = 50, name_textstyle_opts = opts.TextStyleOpts( font_size=16, ), ), xaxis_opts=opts.AxisOpts(name=\"邻居数量 K值\",name_location = 'center',name_gap = 35, name_textstyle_opts = opts.TextStyleOpts( font_size=16, ), ), ) line.set_series_opts( linestyle_opts=opts.LineStyleOpts( color=\"#448CBB\", width=2, ), ) line.render_notebook() 找到最佳的K值为： best_k = k_list[MSE.index(min(MSE))] print(\"最佳邻居数： %d.\" % best_k) 以上我们就完整的用NoteBook做完一个KNN分类机器学习算法的小案例。 "},"Tutorial/Funnel_Analysis.html":{"url":"Tutorial/Funnel_Analysis.html","title":"漏斗分析","keywords":"","body":"漏斗分析案例   漏斗分析是一种在电子商务网站分析中常用的技术，SmartNoteBook是一个基于NoteBook的低代码工具，通过结合SQL和Python的优势，以低代码的方式提供了数据转换、分析和可视化的功能，降低了分析难度，充分发挥了SQL和Python的特点，使分析过程更加高效、灵活和可维护。本文带您使用SmartNoteBook进行漏斗分析(Funnel Analysis)。 什么是漏斗分析(Funnel analysis)   漏斗分析(Funnel analysis)是一种在电子商务网站分析中常用的技术，用于了解用户在网站上的转化过程和行为流程。该分析方法以\"漏斗\"的形式描述了用户从访问网站开始到最终完成某种目标（如购买产品）的整个转化过程。   在电子商务网站分析中，漏斗通常由一系列关键步骤或阶段组成，例如：访问网站、浏览产品、将产品添加到购物车、进行结账、最终完成购买等。每个阶段的用户数量可能会逐渐减少，就像漏斗一样，因此得名\"漏斗分析\"。   通过漏斗分析，运营人员可以识别出在转化过程中的瓶颈或流失点，分析哪些步骤导致了用户的流失，进而采取措施改进用户体验、优化转化率。这种分析方法有助于发现网站/APP存在的问题，并制定针对性的优化策略，以提高整体的转化效果。 AIDA模型   AIDA模型是漏斗分析的理论基础，AIDA模型是一种营销的理论框架，漏斗分析基于AIDA模型提供了一种数据分析的方法。   AIDA模型是一种市场营销模型，旨在描述消费者在购买过程中经历的心理阶段，包括认知（Awareness）、兴趣（Interest）、渴望（Desire）和行动（Action）。该模型强调在推销产品或服务时，通过引起消费者的注意、建立兴趣和渴望，最终促使他们采取行动。它主要关注的是消费者心理状态和推销策略。   AIDA模型通过 Awareness、Interest、Desire 和 Action 追踪客户,是一个购买漏斗，买家在每个阶段来回走动，以支持他们进行最终购买。 AIDA模型在电子商务转化漏斗过程中可能的映射： 认知（Awareness）--> 网站访问：用户了解我们的产品并且我们引起了他们的注意。 兴趣（Interest）--> 浏览商品：用户开始以有意义的方式与我们的产品进行交互。 渴望（Desire）--> 加入购物车：用户体验到我们的产品的价值并且有动力进行转化。 行动（Action）--> 购买产品 ：用户进行转化。 漏斗分析 为了便于漏斗分析，我们引用kaggle (https://www.kaggle.com/datasets/aerodinamicc/ecommerce-website-funnel-analysis) 上的一组数据集，包含五个数据集，分别为：home_page_table、search_page_table、payment_page_table、payment_confirmation_table、user_table，他们数据示例和关系如下： 创建漏斗(全渠道的漏斗分析) 加载包和引入数据： import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import plotly.express as px home_page = pd.read_csv('/home/home_page_table.csv') search = pd.read_csv('/home/search_page_table.csv') payment_page = pd.read_csv('/home/payment_page_table.csv') payment_confirm = pd.read_csv('/home/payment_confirmation_table.csv') user = pd.read_csv('/home/user_table.csv') 合并数据： SELECT user.user_id,device,sex, home_page.page as page FROM user ,home_page where user.user_id=home_page.user_id union all SELECT user.user_id,device,sex, search.page as page FROM user , search where user.user_id=search.user_id union all SELECT user.user_id,device,sex, payment_page.page as page FROM user ,payment_page where user.user_id=payment_page.user_id union all SELECT user.user_id,device,sex, payment_confirm.page as payment_confirm FROM user , payment_confirm where user.user_id=payment_confirm.user_id ; 转换数据： select page , count(*) as page_count from all_data group by page order by page_count desc 生成全渠道漏斗图： a_fig = px.funnel(over_all_funnel, y='page', x='page_count', width=800, height=400) a_fig.show() 终端类型漏斗 按照终端类型进行漏斗分析，首先汇总数据： select page,device , count(*) as page_count from all_data group by page ,device order by page_count desc 输出漏斗图： d_fig = px.funnel(device_funnel, y='page', x='page_count', color='device', width=800, height=400) d_fig.show() 性别分类的漏斗分析 按照性别进行漏斗分析，首先汇总数据： select page,sex , count(*) as page_count from all_data group by page ,sex order by page_count desc 输出漏斗图： 应用数据透视图输出漏斗分析   SmartNoteBook在notebook基础上开发低代码的组件完成数据转换、分析和可视化工作，在保持高灵活性、高适应性基础，降低使用门槛。 分析过程的模型视图(Graph图)   SmartNoteBook模型视图(Graph)是用于展现NoteBook中单元格之间的逻辑依赖关系关系。在模型视图中，每个单元格被表示为一个节点，而单元格之间的引用关系则表示为边。通过模型视图，可以更直观地理解和分析NoteBook的逻辑依赖关系，从而提升代码执行效率。   模型视图类似于脑图，它能够辅助数据建模人员更好地梳理和优化模型。通过观察模型视图，可以更清晰地了解各个单元格之间的关联，帮助优化代码结构和流程，提高建模过程的效率和可维护性。此外，模型视图也方便了模型的分享，可以通过可视化的方式展示NoteBook的结构和逻辑，便于与他人交流和合作。 上述整个过程是使用SmartNoteBook 实现的，通过 SQL 和 Python 的结合，大大降低分析难度，充分发挥 SQL 与 Python 各自特点，完美组合。 "},"Tutorial/Cohort_Analysis.html":{"url":"Tutorial/Cohort_Analysis.html","title":"留存分析","keywords":"","body":"群组分析案例（cohort analysis） 什么是cohort analysis   \"Cohort\"是指一组群体或组织的意思，而\"Cohort Analysis\"可以翻译为\"分组分析\"或\"同期分析\"。Cohort分析通过比较具有相同属性的可比较群体的留存情况，来发现影响短期、中期和长期留存的因素。Cohort分析的受欢迎之处还在于其简单直观的方法。相较于繁琐的损失分析、RFM或用户聚类等方法，Cohort分析只需要一个简单的图表，甚至不需要进行复杂的运算，就能直观地描述用户在一段时间周期内的留存（或流失）变化情况。   \"Cohort\"可以被理解为具有共同特征的用户群体，例如共同的注册时间段或购买偏好。我们可以分析一个群组随着时间的推移而表现，并将其与其他群组进行比较。 时间群组是在特定时间段内注册某产品或服务的客户集合。分析这些群组可以展示客户行为与他们开始使用公司产品或服务的时间之间的关系。这个时间段可以是每月、每季甚至每天。 行为群组是过去购买产品或订阅服务的客户，按照他们所注册的产品或服务类型进行分组。基本级别服务的客户与高级服务的客户可能有不同的需求。了解不同群组的需求可以帮助公司为特定细分市场设计定制的服务或产品。 规模群组指的是根据购买公司产品或服务的规模对客户进行分组。这种分类可以基于客户在一段时间后的消费金额进行分组。   Cohort Analysis可以通过分析以下问题来提供洞察： 用户随着时间推移的行为如何变化？ 不同群组之间的行为差异是什么？ 自推出新产品/新功能以来，用户行为有何变化？ 随着时间推移，留存率如何变化？ 用户对新功能的采用速度有多快？ 不同用户群组的客户终身价值（Customer Lifetime Value, CLV）是多少？ 用户未来的行为可能是什么？ 如何进行cohort analysis 让我们先来理解一下三个概念：维度、粒度、指标。 维度（Cohort group）：用户分组的方式，例如：如按用户的新增日期进行分组，时间就是维度；如按新用户的来源渠道进行分组，渠道就是维度。维度是cohort analysis 分析图Y轴的分类。 粒度（群体期间Cohort period/期间间隔 Cohort interval）：时间周期的颗粒度，时间切片的大小，比如天、周、月等；时间颗粒度是cohort analysis 分析图X轴的切分粒度。 指标（Cohort Index）：指群组间在时间周期内比对的分析指标数值，比如留存率、ARPU等。   理解了维度、粒度、指标后，根据要分析的业务场景合理定义维度、粒度和指标，然后根据数据情况进行计算出cohort 二维表，然后进行展现。下面的例子展现基本的cohort 分析过程。 cohort analysis在SNB的实践   为展示cohort 分析过程，我们引入kaggle 上一个数据集（https://www.kaggle.com/datasets/jihyeseo/online-retail-data-set-from-uci-ml-repo），数据集的格式如下（参见 图：原始数据）： InvoiceNo发票编号 StockCode库存代码 Description描述 Quantity数量 InvoiceDate发票日期/交易日期 UnitPrice单价 CustomerID客户编号 Country国家 对于群体分析（cohort analysis），我们需要创建一些标签： 群体期间（Cohort period）/期间间隔（Cohort interval）：单笔交易的发票的年份、月份的字符串表示。该数字表示自首次购买以来经过的月份数量为期间间隔（Cohort interval）。 群体组（Cohort group）：客户首次购买的年份和月份的字符串表示。该标签在特定客户的所有发票中都是相同的。本例：在同一月份首次购买的用户为一组。 群体指数（Cohort Index）：指群组间在时间周期内比对的分析指标数值，比如留存率、ARPU等，本例：计算留存率 引入数据 引入python包和加载数据、清洗数据。 import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns all_data = pd.read_excel('/home/data/Online_Retail.xlsx') all_data= all_data.dropna(subset=['CustomerID']) all_data = all_data.drop_duplicates() all_data=all_data[(all_data['Quantity']>0) & (all_data['UnitPrice']>0)] 应用SQL 开窗函数，   SmartNoteBook 内置dfSQL引擎，可以通过SQL 方式操作Pandas DataFrame ，大大降低数据集转换难度，充分发挥SQL能力，内置dfSQL引擎主流操作方式、支持绝大部分主流函数、支持开窗函数。 select CustomerID,InvoiceDate,cohort_date from ( select *, min(InvoiceDate) over(partition by CustomerID) as cohort_date from all_data) group by CustomerID,InvoiceDate,cohort_date 计算期间间隔 计算cohort_month、期间间隔（interval）、去除同一月份同一客户的重复记录。 select distinct * from ( select CustomerID,strftime('%Y-%m', cohort_date) as cohort_month, strftime('%Y-%m',InvoiceDate) as invoice_month , strftime('%m',InvoiceDate) - strftime('%m', cohort_date)+(strftime('%Y',InvoiceDate)-strftime('%Y', cohort_date)) * 12 AS cohort_interval from all_chort_data ) 透视图进行二维矩阵生成   SmartNoteBook作为数据分析/数据科学平台，为便捷数据转换操作，开发低代码数据转换组件，比如透视图（pivot）方便进行数据转换。   数据透视表将DataFrame作为输入，根据您的配置对其进行聚合，并返回输出一个DataFrame的数据对象，该数据对象可以在应用中预览和显示或在NoteBook后续单元格中使用。 将字段从选取列表中拖动到对应的配置中 行：作为聚合依据的字段，垂直呈现 列：作为聚合依据的字段，水平呈现 值：选择需要聚合和计算的字段，并设置计算方式 计算留存率并输出   重复列用python 便捷计算方式计算留存率，并利用python 可视化能力展现留存图。 retention_table.index=retention_table['cohort_month'] retention_table = retention_table.drop('cohort_month',axis=1,inplace=False) cohort_size = retention_table.iloc[:,0] retention_table = retention_table.divide(cohort_size,axis=0) retention_table = retention_table.replace(0, np.nan) retention_table.columns=[i.split('_')[0] for i in retention_table.columns] plt.figure(figsize=(15, 8)) plt.title('Retention rates') sns.heatmap(data=retention_table,annot = True,fmt = '.0%',vmin = 0.0,vmax = 0.5,cmap=\"BuPu_r\") plt.show() 留存分析模型视图(流程图)   SmartNoteBook模型视图(Graph)是用于展现NoteBook中单元格之间的逻辑依赖关系关系。在模型视图中，每个单元格被表示为一个节点，而单元格之间的引用关系则表示为边。通过模型视图，可以更直观地理解和分析NoteBook的逻辑依赖关系，从而提升代码执行效率。   上述整个过程是使用SmartNoteBook 实现的，通过 SQL 和 Python 的结合，大大降低cohort analysis群组分析难度，充分发挥 SQL 与 Python 各自特点，完美组合。 "},"Tutorial/RFM_Analysis.html":{"url":"Tutorial/RFM_Analysis.html","title":"RFM分析","keywords":"","body":"客户价值分析案例   RFM模型是客户价值划分的重要工具和手段，用于评估客户的价值和利益创造能力。通过考量客户的最近购买时间(Recency)、购买频率(Frequency)和购买金额(Monetary)，将客户分成不同群体，如忠诚客户、高价值客户和流失客户。这有助于制定个性化的营销策略，提高市场营销效果，同时也能及时识别潜在流失客户并采取挽留措施，提升客户保持率。RFM提供了简单而有效的客户行为评估方法，作为众多客户关系管理（CRM）分析模式之一，对营销决策和客户关系管理具有重要意义，RFM模型得到广泛应用和提及。 什么是RFM RFM是\"Recency（最近）、Frequency（频率）和Monetary（金额）\"的缩写。Recency指的是客户最后一次购买的时间，也就是距离客户最后一次购买的天数。如果是针对网站或应用的情况，可以解释为客户最后一次访问的日期或最后一次登录的时间。 Frequency表示在一定时期内购买的次数。这个时期可以是3个月、6个月或1年。因此，我们可以理解这个值代表了客户使用公司产品的频率或数量。数值越大，客户的参与度就越高。我们可以把这些客户称为VIP吗？不一定。因为我们还必须考虑到他们每次购买实际支付的金额，也就是货币价值。 Monetary指的是客户在给定时期内花费的总金额。因此，大额消费者将与其他客户（如MVP或VIP）区分开来。 使用SNB进行RFM分析   为展示RFM 分析过程，引入kaggle 上一个数据集（https://www.kaggle.com/datasets/jihyeseo/online-retail-data-set-from-uci-ml-repo），数据集的格式如下（参见下图）： InvoiceNo发票编号 StockCode库存代码 Description描述 Quantity数量 InvoiceDate发票日期/交易日期 UnitPrice单价 CustomerID客户编号 Country国家 主要分析步骤如下： a. 引入数据，利用dfSQL计算每个客户的Recency、Frequency、MonetaryValue b. 利用分位数（四分位数）分别对Recency、Frequency、MonetaryValue 分桶操作，分别将Recency、Frequency、MonetaryValue分成4个等级并对应为定义分数值(1-4分），并计算每个客户的RFM总分（3-12分)。并统计分数下对应客户数量、平均Recency、平均Frequency、平均MonetaryValue等。 c. 按照rfm分数段将用户划分三个等级:黄金用户(10-12分)、白银用户(6-9分)、青铜用户(3-5分) 三个级别，并统计分析每个用户群组下分布情况，包括客户数量、平均Recency、平均Frequency、平均MonetaryValue。 d. 按照rfm分钟进行k-means聚类：标准化、最佳聚类簇数(分组数)的筛选、聚类、统计分析每个簇（群组)的用户分布和FRM值的统计情况。 e. 对比分析分段分类和算法聚类的每群组下分布对比，包括蛇形图和RFM分位数热图(Heatmap of RFM quantile),对比二者的合理性。 引入数据和处理数据 引入python包和加载数据、清洗数据。 import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import datetime as dt all_data = pd.read_excel('/home/data/Online_Retail.xlsx') all_data= all_data.dropna(subset=['CustomerID']) all_data = all_data.drop_duplicates() all_data=all_data[(all_data['Quantity']>0) & (all_data['UnitPrice']>0)] snapshot_date = all_data['InvoiceDate'].max() + dt.timedelta(days=1) __SNB_DisplayTable(all_data) 计算Recency、Frequency、MonetaryValue   SmartNoteBook 内置dfSQL引擎，可以通过SQL 方式操作Pandas DataFrame ，大大降低数据集转换难度，充分发挥SQL能力，内置dfSQL引擎主流操作方式、支持绝大部分主流函数、支持开窗函数。   利用dfSQL计算Recency、Frequency、MonetaryValue 值。 select CustomerID, floor(julianday('')-julianday(max(InvoiceDate))) as Recency, count(*) as Frequency , floor(sum(UnitPrice*Quantity)) as MonetaryValue from all_data group by CustomerID 分箱RFM值和RFM 评分   对Recency、Frequency、MonetaryValue 分别进行分箱操作，不同箱进行评分，计算总分，最高跟12分，最低分为3分，这个分数代表用户的价值。 #对Recency、Frequency、MonetaryValue 分别进行分箱操作，不同箱进行评分，计算总分 r_labels =range(4,0,-1) f_labels=range(1,5) m_labels=range(1,5) r_quartiles = pd.qcut(rfm_data['Recency'], q=4, labels = r_labels) f_quartiles = pd.qcut(rfm_data['Frequency'],q=4, labels = f_labels) m_quartiles = pd.qcut(rfm_data['MonetaryValue'],q=4,labels = m_labels) rfm_data = rfm_data.assign(R=r_quartiles,F=f_quartiles,M=m_quartiles) def add_rfm(x) : return str(int(x['R'])) + str(int(x['F'])) + str(int(x['M'])) rfm_data['RFM_Segment'] = rfm_data.apply(add_rfm,axis=1 ) rfm_data['RFM_Score'] = rfm_data[['R','F','M']].sum(axis=1) __SNB_DisplayTable(rfm_data) 分析用户RFM细分群组的用户情况   统计分数下对应客户数量、平均Recency、平均Frequency、平均MonetaryValue等。即用户RFM细分群组的用户情况。 利用SmartNoteBook内置透视图低代码插件分析每个RFM分数的汇总指标情况。 使用RFM评分将客户分为黄金、白银和青铜细分市场 def segments(df): if df['RFM_Score'] > 9 : return '黄金' elif (df['RFM_Score'] > 5) and (df['RFM_Score'] Kmeans聚类 上述是利用分段的方式计算分数进行分组的方法，接下来利用聚类算法对用户进行分组，首先分析Recency、Frequency、MonetaryValue的值分布情况是否适合Kmeans聚类（或进行变换操作）、选择最佳簇数(聚类数目)、聚类。 在实现Kmeans聚类之前，必须检查特征Recency、Frequency、MonetaryValue是否符合k-means假设： 变量的对称分布（不偏斜） 平均值相同的变量 具有相同方差的变量 检查是否符合k-means假设及变换处理 f,ax = plt.subplots(figsize=(10, 12)) plt.subplot(3, 1, 1); sns.distplot(rfm_data.Recency, label = 'Recency') plt.subplot(3, 1, 2); sns.distplot(rfm_data.Frequency, label = 'Frequency') plt.subplot(3, 1, 3); sns.distplot(rfm_data.MonetaryValue, label = 'Monetary Value') plt.style.use('fivethirtyeight') plt.tight_layout() plt.show() rfm_log = rfm_data[['Recency', 'Frequency', 'MonetaryValue']].apply(np.log, axis = 1).round(3) f,ax = plt.subplots(figsize=(10, 12)) plt.subplot(3, 1, 1); sns.distplot(rfm_log.Recency, label = 'Recency') plt.subplot(3, 1, 2); sns.distplot(rfm_log.Frequency, label = 'Frequency') plt.subplot(3, 1, 3); sns.distplot(rfm_log.MonetaryValue, label = 'Monetary Value') plt.style.use('fivethirtyeight') plt.tight_layout() plt.show() K-Means聚类的实现   实现K-Means关键步骤如下：数据预处理(数据标准化)、选择聚类的最佳簇数(聚类数目)、进行k-均值聚类、分析每个集群的平均RFM值。 数据预处理：数据标准化 from sklearn.preprocessing import StandardScaler scaler = StandardScaler() scaler.fit(rfm_log) #Store it separately for clustering rfm_normalized= scaler.transform(rfm_log) rfm_normalized array([[ 1.40998159, -2.77997064, 3.69639451], [-2.14657818, 1.16036535, 1.41192044], [ 0.38364809, -0.17983348, 0.72008734], ..., [-1.1788923 , -0.89839206, -1.11002495], [-1.66273524, 2.20299461, 0.8222 ], [-0.00454336, 0.43650655, 0.7375019 ]]) 选择聚类的最佳簇数(聚类数目) 定义聚类的最佳簇数(聚类数目)，主要有以下方法 可视化方法 - 弯曲点准则 数学方法 - 轮廓系数 实验和解释 弯曲点准则方法 绘制聚类数目与簇内平方误差之和（SSE）的关系图 - 即每个数据点到其簇中心的平方距离之和 在图中找到一个\"弯曲点\" 弯曲点 - 表示一个\"最佳\"簇数(聚类数目)的点 应用\"弯曲点准则\"找到最佳的簇数(聚类数目)： from sklearn.cluster import KMeans inertias=[] for k in ks : kc = KMeans(n_clusters=k,random_state=1) kc.fit(rfm_normalized) inertias.append(kc.inertia_) f, ax = plt.subplots(figsize=(15, 8)) plt.plot(ks, inertias, '-o') plt.xlabel('Number of clusters, k') plt.ylabel('Inertia') plt.xticks(ks) plt.style.use('ggplot') plt.title('What is the Best Number for KMeans ?') plt.show() 选择最佳簇数(聚类数目)为3，训练k-means聚类 kc = KMeans(n_clusters= 3, random_state=1) kc.fit(rfm_normalized) cluster_labels = kc.labels_ rfm_rfm_k3 = rfm_data.assign(K_Cluster = cluster_labels) rfm_rfm_k3.groupby('K_Cluster').agg({'Recency': 'mean','Frequency': 'mean', 'MonetaryValue': ['mean', 'count'],}).round(0) 对比分析分段分类和算法聚类   对比分析分段分类和算法聚类的每群组下分布对比，包括蛇形图和RFM分位数热图(Heatmap of RFM quantile),对比二者的合理性。 分段分类和算法聚类蛇形图 rfm_normalized = pd.DataFrame(rfm_normalized,index=rfm_data.index,columns=['Recency', 'Frequency', 'MonetaryValue']) rfm_normalized['K_Cluster'] = kc.labels_ rfm_normalized['General_Segment'] = rfm_data['General_Segment'] rfm_normalized['CustomerID'] = rfm_data['CustomerID'] rfm_normalized.reset_index(inplace = True) #Melt the data into a long format so RFM values and metric names are stored in 1 column each rfm_melt = pd.melt(rfm_normalized,id_vars=['CustomerID','General_Segment','K_Cluster'],value_vars=['Recency', 'Frequency', 'MonetaryValue'], var_name='Metric',value_name='Value') rfm_melt f, (ax1, ax2) = plt.subplots(1,2, figsize=(15, 8)) sns.lineplot(x = 'Metric', y = 'Value', hue = 'General_Segment', data = rfm_melt,ax=ax1) # a snake plot with K-Means sns.lineplot(x = 'Metric', y = 'Value', hue = 'K_Cluster', data = rfm_melt,ax=ax2) plt.suptitle(\"Snake Plot of RFM\",fontsize=24) #make title fontsize subtitle plt.show() 分段分类和算法聚类的统计对比   识别每个分段属性的相对重要性的有用技术 计算每个聚类的Recency、Frequency、MonetaryValue平均值 计算所有用户的Recency、Frequency、MonetaryValue平均值 通过除以它们并减去1来计算重要性得分（确保当集群平均值等于总体平均值时返回0）   用热图展现对比。热图是数据的图形表示，其中较大的值以较暗的比例着色，较小的值以较小的比例着色。我们可以通过颜色非常直观地比较各组之间的差异。 cluster_avg = rfm_rfm_k3[['K_Cluster','Recency', 'Frequency','MonetaryValue']].groupby(['K_Cluster']).mean() population_avg = rfm_rfm_k3[['Recency', 'Frequency','MonetaryValue']].mean() relative_imp = cluster_avg / population_avg - 1 relative_imp.round(2) # the mean value in total total_avg = rfm_data[['Recency', 'Frequency','MonetaryValue']].mean() # calculate the proportional gap with total mean cluster_avg = rfm_data[['General_Segment','Recency', 'Frequency','MonetaryValue']].groupby('General_Segment').mean().iloc[:, 0:3] prop_rfm = cluster_avg/total_avg - 1 prop_rfm.round(2) 热图展现： f, (ax1, ax2) = plt.subplots(1,2, figsize=(15, 5)) sns.heatmap(data=relative_imp, annot=True, fmt='.2f', cmap='Blues',ax=ax1) ax1.set(title = \"Heatmap of K-Means\") # a snake plot with K-Means sns.heatmap(prop_rfm, cmap= 'Oranges', fmt= '.2f', annot = True,ax=ax2) ax2.set(title = \"Heatmap of RFM quantile\") plt.suptitle(\"Heat Map of RFM\",fontsize=20) #make title fontsize subtitle plt.show()   通过以上数值比对分析，分段分组和聚类分组二者基本是一致的，二者的特征表现差距比较小，聚类分组是比较合理的。 RFM分析的模型视图(流程图)   SmartNoteBook模型视图(Graph)是用于展现NoteBook中单元格之间的逻辑依赖关系关系。在模型视图中，每个单元格被表示为一个节点，而单元格之间的引用关系则表示为边。通过模型视图，可以更直观地理解和分析NoteBook的逻辑依赖关系，从而提升代码执行效率。   上述整个过程是使用SmartNoteBook 实现的，利用SQL和Python 分布计算了用户的Recency、Frequency、MonetaryValue值并进行用户价值的评分、用户价值分组并进行每个用户群组的统计分析，同时利用算法进行聚类分组并进行比对分析，整个过程还是较为复杂的，充分利用了SQL与Python的融合、创建模型及可视化分析展现，充分展现用户价值的RFM挖掘过程。 "},"Tutorial/Market_Basket_Analysis.html":{"url":"Tutorial/Market_Basket_Analysis.html","title":"购物篮分析","keywords":"","body":"购物篮分析案例   当谈及购物篮分析和关联规则算法时，一则经典故事《啤酒与尿布》(它的真实性存在争议,有人认为是商业传奇，也有人认为是虚构的)常常被提及。这个故事以一家大型零售连锁店的数据分析为背景，引人入胜地揭示了消费者购物行为中的意外关联。故事中，分析师发现在某个城市的分店中，啤酒和尿布的销售量竟然时常同时增长。这个奇怪的现象引发了深入探究，从而揭示了隐藏在数据背后的宝贵信息。让我们一同探索这个引人入胜的故事，了解购物篮分析的精髓和应用。 什么购物篮分析   购物篮分析是一种数据挖掘技术，用于揭示消费者购买行为中的相关性和关联规律。当顾客在购物篮中同时购买多个商品时，我们可以通过分析这些购买组合的频率，找出那些经常一起出现的商品组合，这些被称为频繁项集。   频繁项集是指在交易数据集中经常同时出现的商品组合。它通过计算支持度来衡量，支持度指的是某个商品组合在所有交易中出现的频率。通过识别频繁项集，我们可以了解到哪些商品经常同时被购买，从而为商家提供宝贵的市场洞察。而关联规则是从频繁项集中提取出的有意义的关联关系。关联规则通常以“A → B”的形式表示，表示当顾客购买商品A时，他们很可能也会购买商品B。关联规则可以通过计算置信度和提升度来衡量其关联强度和实际意义。置信度表示当商品A被购买时，同时购买商品B的概率。提升度则衡量了商品A的购买对商品B购买的影响程度。   购物篮分析的应用广泛，涵盖了零售业、市场营销、推荐系统等领域。它帮助企业深入了解消费者行为，提供个性化的购物体验和精准的营销策略，从而在竞争激烈的市场中脱颖而出。   在购物篮分析中，支持度、置信度和提升度是三个重要的指标，用于衡量商品之间的相关性和关联强度。 支持度(Support)   支持度是指某个商品组合在所有交易中出现的频率。它可以帮助我们确定哪些商品组合是频繁出现的，从而识别出潜在的关联规则。支持度的计算公式为：支持度(A) = (包含A的交易数) / (总交易数)。通过设置支持度的阈值，我们可以筛选出具有足够重要性的商品组合。 今天共有1000笔订单，商品A为可乐，商品B为薯片，其中同时购买可乐和薯片的次数是100次，那么可乐+薯片组合的支持度就是100/1000=10%。 置信度(Confidence)   置信度衡量了当顾客购买了商品A时，他们同时购买商品B的概率。它可以帮助我们判断商品之间的关联强度。置信度的计算公式为：置信度(A → B) = (同时购买A和B的交易数) / (购买A的交易数)。通过设置置信度的阈值，我们可以筛选出具有较强关联的商品组合。 上述订单中，购买可乐的订单为250，则其置信度是100/250=40% 提升度(Lift)   提升度是用来衡量商品B的出现是否受到商品A的购买的影响程度。提升度大于1表示商品A的购买会对商品B的购买产生正向影响，提升度等于1表示两者之间没有关联，提升度小于1表示商品A的购买会对商品B的购买产生负向影响。提升度的计算公式为：提升度(A → B) = 置信度(A → B) / 支持度(B)。通过设置提升度的阈值，我们可以筛选出具有实际意义和价值的关联规则。 购买A（可乐）对购买B（薯片）的提升作用，Lift(A→B)=0.4/0.1 =4 ,所以可乐对薯片的提升效果很不错的。   这些指标的应用使我们能够从大量的交易数据中挖掘出有意义的关联规则，为企业决策提供重要参考。 使用SNB进行购物篮分析   为展示购物篮分析过程，引入kaggle 上一个数据集(https://www.kaggle.com/datasets/aslanahmedov/market-basket-analysis),这个数据集主要字段为: BillNo:订单号 Itemname：商品名称 Quantity：数量 Date：日期 Price ：单价 CustomerID：客户ID Country：国家   数据样例如下：   为了展示关联规则的分析过程，按照最为简化的方式进行分析，选取BillNo、Itemname,一个BillNo 为一个事务，其他因素忽略。为了便于理解支持度(Support)、置信度(Confidence)、提升度(Lift)的计算过程，全程主要就计算过程使用dfSQL 实现。 引入数据   kaggle 下载数据，上传到计算环境中，引入包加载数据，同时做一下去重和去空操作。定义结果数据集(DataFrame):uni_df import pandas as pd all_data=pd.read_csv('/home/data/Assignment-1_Data.csv', sep=';') __SNB_DisplayTable(all_data) select BillNo,Itemname from all_data where Itemname is not null group by BillNo,Itemname 计算总订单数据   利用SmartNoteBook 内置的SQL单元格和dfSQL引擎，在数据集上进行计算总订单数，并将保存python变量里：total_num。   后面的绝大计算方式都是SQL，都是dfSQL。dfSQL引擎是SmartNoteBook内置引擎，可以通过SQL 方式操作Pandas DataFrame ，大大降低数据集转换难度，充分发挥SQL能力，内置dfSQL引擎主流操作方式、支持绝大部分主流函数、支持开窗函数，性能卓越，比pandas 转换性能提升一倍。 select count(distinct BillNo) from all_data total_num=total_df.iloc[0,0] print(total_num) 计算商品的订单数   这里SQL统计商品的订单数，定义结果数据集(DataFrame):item_df select Itemname,count(distinct BillNo) as a_count from uni_df group by Itemname 计算支持度(Support)   这里使用uni_df的数据集进行join 合并，也就说在同一订单内的商品(item)进行的卡尔积形成两两商品(item)组合，这里引用python里面订单总数的变量。然后过滤汇总统计操作，为了演示方便，这里纯属自己随意定义support > 0.02 筛选规则。定义结果数据集(DataFrame):s_df select a.Itemname as a_name,b.Itemname as b_name, count(distinct a.BillNo) as ab_count, count(distinct a.BillNo)/ as support from uni_df a,uni_df b where a.BillNo = b.BillNo and a.Itemname > b.Itemname group by a.Itemname,b.Itemname having support > 0.02 order by support desc 计算置信度(confidence、lift)   合并数据集(DataFrame)s_df、item_df 得到关联规则集：ar_df. select a_name,b_name,support, ab_count/item_df.a_count as confidence, ab_count/item_df.a_count/support as lift from s_df,item_df where s_df.a_name=item_df.Itemname 购物篮分析的模型视图(流程图)   SmartNoteBook模型视图(Graph)是用于展现NoteBook中单元格之间的逻辑依赖关系关系。在模型视图中，每个单元格被表示为一个节点，而单元格之间的引用关系则表示为边。通过模型视图，可以更直观地理解和分析NoteBook的逻辑依赖关系，从而提升代码执行效率。   上述整个过程是使用SmartNoteBook 实现的，利用SQL和Python 分布计算/挖掘商品的频繁项集和关联规则，简单实现了购物篮分析过程，希望对大家有所借鉴。 "},"Tutorial/KNN.html":{"url":"Tutorial/KNN.html","title":"KNN","keywords":"","body":"KNN模型预测案例 导入包和数据 import numpy as np import pandas as pd import seaborn as sns sns.set_palette('husl') import matplotlib.pyplot as plt %matplotlib inline from sklearn import metrics from sklearn.neighbors import KNeighborsClassifier from sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split import warnings warnings.filterwarnings('ignore') # 该数据文件已上传至用户默认的WorkSpace，文件路径可直接读取使用 data = pd.read_csv('/home/Iris.csv') 数据预览 共有150个观测值，每个观测值有4个特征（花萼长度、花萼宽度、花瓣长度、花瓣宽度）。 没有缺失值，所以我们不需要担心这个问题。 每个物种（山鸢尾、变色鸢尾、维吉尼亚鸢尾）有50个观测值。 data.head() data.info() data.describe() data['Species'].value_counts() 数据可视化 在绘制特征的成对图后，可以清楚地看出山鸢尾（粉色）的特征之间的关系与其他两个物种明显不同。 另外两个物种，变色鸢尾（棕色）和维吉尼亚鸢尾（绿色），它们之间的成对关系存在一些重叠。 tmp = data.drop('Id', axis=1) g = sns.pairplot(tmp, hue='Species', markers='+') plt.show() g = sns.violinplot(y='Species', x='SepalLengthCm', data=data, inner='quartile') plt.show() g = sns.violinplot(y='Species', x='SepalWidthCm', data=data, inner='quartile') plt.show() g = sns.violinplot(y='Species', x='PetalLengthCm', data=data, inner='quartile') plt.show() g = sns.violinplot(y='Species', x='PetalWidthCm', data=data, inner='quartile') plt.show() 使用scikit-learn进行建模 X = data.drop(['Id', 'Species'], axis=1) y = data['Species'] # print(X.head()) print(X.shape) # print(y.head()) print(y.shape) 在相同数据集上进行训练和测试 不建议使用这种方法，因为最终目标是使用模型未曾见过的数据集来预测鸢尾花的物种。 这种方法还存在过拟合训练数据的风险。 # experimenting with different n values k_range = list(range(1,26)) scores = [] for k in k_range: knn = KNeighborsClassifier(n_neighbors=k) knn.fit(X, y) y_pred = knn.predict(X) scores.append(metrics.accuracy_score(y, y_pred)) plt.plot(k_range, scores) plt.xlabel('Value of k for KNN') plt.ylabel('Accuracy Score') plt.title('Accuracy Scores for Values of k of k-Nearest-Neighbors') plt.show() logreg = LogisticRegression() logreg.fit(X, y) y_pred = logreg.predict(X) print(metrics.accuracy_score(y, y_pred)) 将数据集分为训练集和测试集 优势 通过将数据集伪随机地分为两个独立的集合，我们可以使用一个集合进行训练，使用另一个集合进行测试。 这样可以确保我们不会在两个集合中使用相同的观测值。 比使用整个数据集进行训练更灵活且更快速。 缺点 测试集的准确率可能会因为其中包含的观测值不同而有所变化。 可以通过使用k折交叉验证来弥补这个缺点。 注意事项 模型的准确率取决于测试集中的观测值，这由伪随机数生成器的种子（random_state参数）确定。 随着模型复杂度的增加，训练准确率（在相同数据上训练和测试时获得的准确率）也会增加。 如果模型过于复杂或不够复杂，测试准确率会降低。 对于KNN模型，k的值决定了模型的复杂度。较低的k值意味着模型更复杂。 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=5) print(X_train.shape) print(y_train.shape) print(X_test.shape) print(y_test.shape) # experimenting with different n values k_range = list(range(1,26)) scores = [] for k in k_range: knn = KNeighborsClassifier(n_neighbors=k) knn.fit(X_train, y_train) y_pred = knn.predict(X_test) scores.append(metrics.accuracy_score(y_test, y_pred)) plt.plot(k_range, scores) plt.xlabel('Value of k for KNN') plt.ylabel('Accuracy Score') plt.title('Accuracy Scores for Values of k of k-Nearest-Neighbors') plt.show() logreg = LogisticRegression() logreg.fit(X_train, y_train) y_pred = logreg.predict(X_test) print(metrics.accuracy_score(y_test, y_pred)) 选择KNN模型进行鸢尾花物种预测，使用k = 12 在发现k = 12是一个相对较好的邻居数量后，我使用它来对整个数据集进行模型拟合，而不仅仅是训练集。 knn = KNeighborsClassifier(n_neighbors=12) knn.fit(X, y) # make a prediction for an example of an out-of-sample observation knn.predict([[6, 3, 4, 2]]) "},"Tutorial/Mindsdb_demo.html":{"url":"Tutorial/Mindsdb_demo.html","title":"MindsDB实战","keywords":"","body":"MindsDB(SQL+ML)实战案例   MindsDB(SQL+ML)为智能决策开启了新的大门。从初学者到资深数据科学家，都可以通过学习和使用这些技术，将数据转化为有意义的见解，从而做出更明智的决策。   在探索MindsDB(SQL+ML)的基础时，我们将发现数据的魅力和潜力。这些技术的结合使得数据分析变得更加高效和直观。通过简单的SQL查询，我们可以训练机器学习模型，实现数据的智能化处理，并从中挖掘出有价值的信息。   本篇教程我们来学习MindsDB在Notebook内的使用过程和方式，SmartNotebook 更加简化MindsDB使用。 MindsDB与notebook 融合   SmartNoteBook是协作的、集成的、一站式数据科学/分析环境。SmartNoteBook是参考Jupyter Notebook思想实现数据科学与分析的强大环境，深度融合Python(编程能力、AI能力)与SQL(数据处理)、可视化于一体，更高效编辑、执行和共享数据应用模型，进行数据采集、探索、机器学习、深度学习和交互可视化。开箱即用的数据科学、机器学习工具包；高效编辑器辅助和团队协作跟踪功能；通过Notebook结构化逻辑关系配合自然语言可以很好表现数据分析过程、阐述数据故事，形成数据报告，深层次的挖掘数据、释放数据价值。   SmartNotebook与MindsDB融合上主要以下特征： 免安装，支持Minds配置与管理 SQL单元格支持MindsDB SQL 调试和执行，动态SQL、与Python 的交互 快捷无缝的数据源引入到MindsDB 快速生成API服务 元数据的支持 操作示例演示 关于SNB   SmartNoteBook（简称：SNB）是一款现代化的Notebook工具，它是一个开箱即用、云原生、协作式的在线数据科学与分析平台。SNB具有以下特点： 数据连接：SNB可以连接到各种数据形式，包括数据文件、数据库/仓库、数据湖、图数据库、数据开放平台API等。您可以轻松地获取所需的数据，无论数据存储在哪里。 数据分析与探索：通过SNB可以进行探索性数据分析，内置探索性数据分析的组件、SQL原生支持，支持数据清洗、转换、聚合等操作，深入了解数据的特征和模式。同时也可以使用Python 生态体系内各种强大的工具和库。 建立预测模型与服务API：SNB提供了机器学习和预测建模的功能。支持Scikit-learn、TensorFlow等库，建立预测模型，并将其创建为服务API，供其他应用程序调用和使用。 支持知识图谱挖掘：SNB支持连接图数据库进行关系数据的分析、计算和挖掘，将数据之间的关系和连接进行可视化，有助于发现数据之间的隐藏模式和洞察。 数据可视化与报告生成：SNB提供了丰富的数据可视化功能，敏捷可视化分析和输出，用于展示和传达数据的见解和故事。 仪表盘与报告共享：通过SNB创建交互式的数据仪表盘和报告。可以将数据的洞察和分析结果以直观和易于理解的方式与团队或其他利益相关者共享。 数据智灵(人工智能AI伴侣):用户可以通过自然语言描述数据分析需求生成、编辑、bug修复和文档注释Python或SQL 代码，这种方式可以帮助用户更加轻松地处理和分析数据，尤其是对于那些不熟悉编程的人员来说，使用自然语言描述数据分析需求会更加直观和方便。   SmartNoteBook致力于实现从数据接入到数据价值的全流程，使数据处理和分析变得更加简单、高效和可协作。通过SNB，您可以轻松地进行数据处理、分析和可视化，并通过共享报告和仪表盘将数据的洞察传达给相关人员。 "},"Policy.html":{"url":"Policy.html","title":"隐私政策","keywords":"","body":"隐私政策 欢迎您使用SmartNoteBook数据科学平台！我们非常重视您的隐私保护和个人信息保护。本隐私政策适用于您对SmartNoteBook数据科学平台（以下简称为\"平台\"）的访问和使用留存的信息。 我们尽量以更清晰、更容易被您理解的方式展现本隐私政策，从而希望能够真实地传达我们希望向您传达的信息，并希望您在向我们提供某些信息（其中很可能包括您的个人信息）以及允许我们处理并分享某些信息之前，能够清晰地了解这些信息收集的目的、可能的用途以及其他方面的内容。 本隐私政策适用于\"平台\"所有产品和服务。 若您使用\"平台\"的服务，即表示您认同我们在本政策中所述内容。在将您的信息用于本隐私权政策未涵盖的用途时，我们会事先征求您的同意。 此外，我们在尽可能地为您控制个人信息、保护个人隐私提供更为便捷的方式。我们决不将您的个人账户信息共享给其他第三方使用（但不限于相关政府部门依法律要求检查个人）。 本隐私政策将帮助您了解以下内容： 我们收集哪些信息，以及我们对这些信息的使用方式 我们如何使用 Cookie 和同类技术 我们如何保存及保护您的个人信息 您的权利 我们深知个人信息对您的重要性，也深知为您的信息提供有效保护是我们业务健康可持续发展的基石。感谢您对\"平台\"的使用和信任！我们致力于维持您对我们的信任，恪守适用法律和我们对您的承诺，尽全力保证您的个人信息安全和合理使用。同时，我们郑重承诺，我们将按业界成熟的安全标准，采取相应的安全保护措施来保护您的个人信息。 我们如何收集和使用您的个人信息 个人信息是指以电子或者其他方式记录的能够单独或者与其他信息结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。 为了向您提供更好、更个性化的产品和服务，当您使用以下服务、功能或设置时，我们会以下列方式收集和使用您的个人信息： 您直接提供和我们自动采集的个人信息 注册信息。当您使用\"平台\"注册账号时，您需向我们提供以下信息：邮箱号、并创建密码。 日志信息。我们的服务器会自动记录您的操作记录、日志信息，包括您使用过程中输入的各类文本信息，并回传数据到服务器上进行异常问题的分析、处理、解决，为您提供更优质的服务方案。 事先征得授权同意的例外 请注意：在以下情形中，收集、使用个人信息无需事先征得您的授权同意： (a) 与国家安全、国防安全直接相关的； (b) 与公共安全、公共卫生、重大公共利益直接相关的； (c) 与犯罪侦查、起诉、审判和判决执行等直接有关的； (d) 出于维护您或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； (e) 所收集的个人信息是您自行向社会公众公开的； (f) 从合法公开披露的信息中收集个人信息的，如合法的新闻报道、政府信息公开等渠道； (g) 根据您的要求向您提供产品或服务所必需的； (h) 用于维护所提供的产品或服务的安全稳定运行所必需的，例如发现、处置产品或服务的故障； (i) 法律法规规定的其他情形。 个人信息的去标识化/匿名化处理 在收集到您的个人信息后，我们将通过技术手段及时对数据进行去标识化或匿名化处理。在不泄露您个人信息的前提下，有权对匿名化处理后的用户数据库进行挖掘、分析和利用（包括商业性使用）。 您授权我们在您使用的产品及服务的期间使用您的个人信息，若您注销帐号，我们将停止使用并删除您的个人所有信息、数据。 我们如何使用 Cookie 和同类技术 Cookie和匿名标识符工具。Cookie是支持服务器端（或者脚本）在客户端上存储和检索信息的一种机制。当您使用\"平台\"下的产品或服务时，我们会向您的设备发送一个或多个Cookie或匿名标识符。当您与\"平台\"下的产品服务进行交互时，我们允许Cookie或者匿名标识符发送给\"平台\"服务器。Cookie 通常包含标识符、站点名称以及一些号码和字符。运用Cookie技术，了解您的使用习惯，记住您的偏好，省去您输入重复信息的步骤，为您提供更加周到的个性化服务，或帮您判断您账户的安全性。Cookie还可以帮助我们统计流量信息，分析页面设计的有效性、友好性。 我们不会将 Cookie 用于本政策所述目的之外的任何用途。您可根据自己的偏好管理或删除 Cookie。有关详情，请参见AboutCookies.org。 我们如何保存及保护您的个人信息 保存期限。为了您能够使用\"平台\"服务的多样化产品服务以及有效处理可能产生的争议，除满足《网络安全法》对于数据留存的强制性要求外，我们将在您使用\"平台\"服务期间及相关行为的诉讼时效届满前保存您的个人信息。在超过上述期限后，我们会对您的信息进行删除或进行匿名化处理（即会对您的个人信息进行处理以使您的身份无法被任何第三方识别）。 保存地域。您的个人信息均储存于中华人民共和国境内，如需跨境传输，我们将会单独征得您的授权同意。 安全措施。 我们会以“最小化”原则收集、使用、存储和传输用户信息，并通过服务条款和隐私政策告知您相关信息的使用目的和范围。 我们非常重视信息安全。我们会采取适当的符合业界标准的安全措施和技术手段存储和保护您的个人信息，以防止您的信息丢失、遭到被未经授权的访问、公开披露、使用、毁损、丢失或泄漏。我们会采取一切合理可行的措施，保护您的个人信息。我们会使用加密技术确保数据的保密性；我们会使用受信赖的保护机制防止数据遭到恶意攻击。 我们会对员工进行数据安全的意识培养和安全能力的培训和考核，加强员工对于保护个人信息重要性的认识。我们会对处理个人信息的员工进行身份认证及权限控制，并会与接触您个人信息的员工、合作伙伴签署保密协议，明确岗位职责及行为准则，确保只有授权人员才可访问个人信息。若有违反保密协议的行为，会被立即终止与本单位的合作关系，并会被追究相关法律责任，对接触个人信息人员在离岗时也提出了保密要求。 我们也请您理解，在互联网行业由于技术的限制和飞速发展以及可能存在的各种恶意攻击手段，即便我们竭尽所能加强安全措施，也不可能始终保证信息的百分之百安全。请您了解，您使用我们的产品或服务时所用的系统和通讯网络，有可能在我们控制之外的其他环节而出现安全问题。 根据我们的安全管理制度，个人信息泄露、毁损或丢失事件被列为最特大安全事件，一经发生将启动本单位最高级别的紧急预案，由相关部门组成联合应急响应小组紧急处理。 您的权利 按照中国相关的法律、法规、标准，以及其他国家、地区的通行做法，我们保障您对自己的个人信息行使以下权利： 访问权。原则上您可以通过web登录并访问您的个人信息，并使用相应的服务。（例如：访问或编辑您的帐户中的个人资料信息、更改您的账户信息等。） 更正权。当您发现您的个人信息有错误时，您有权对错误或不完整的信息作出更正或更新，您可以自行在\"平台\"内进行更正。 删除权。在以下情形中，您可以向我们提出删除个人信息的请求： 如果我们终止\"平台\"下某个产品运营及服务； 如果您注销了帐号，我们会删除您的个人信息及数据或做匿名化处理； 涉及商业秘密的。如果我们违反法律法规或与您的约定收集、使用、与他人共享或转让您的个人信息，您有权要求我们及第三方删除。 撤销权。每个业务功能需要一些基本的个人信息才能得以完成。如平台有额外对您的个人信息的收集和使用，您可以随时给予或收回您的授权同意。 注销权。您随时可注销此前注册的账户。 提前获知产品和服务停止运营权。 在以下情形中，按照法律法规要求，我们将无法响应您的更正、删除、注销信息的请求： 与国家安全、国防安全直接相关的； 与公共安全、公共卫生、重大公共利益直接相关的； 与犯罪侦查、起诉、审判和执行判决等直接相关的； 我们有充分证据表明您存在主观恶意或滥用权利的（如您的请求将危害公共安全和其他人合法权益，或您的请求超出了一般技术手段和商业成本可覆盖的范围）； 响应个人信息主体的请求将导致您或其他个人、组织的合法权益受到严重损害的； 涉及商业秘密的。 注销账户 您注销账户后，我们将停止为您提供的所有产品和服务，并依据您的要求，除法律法规另有规定外，我们将及时删除您的个人信息。 您的账户注销，将面临以下风险及问题： 账户内未完成的服务、报告、研究会因您账户注销而无法继续执行； 如您的账户因违法违规操作或侵犯他人合法权益导致处罚和纠纷、投诉所必需要的信息，并该等期限届满后对相关个人信息进行删除或匿名化处理； "},"Terms.html":{"url":"Terms.html","title":"服务条款","keywords":"","body":"服务条款 欢迎申请使用SmartNoteBook数据科学平台（下列简称为\"平台\"）提供的服务。请您（下列简称为用户）仔细阅读以下全部内容。如用户不同意本服务条款任意内容，请勿注册或使用\"平台\"服务。如用户通过进入注册程序并勾选我同意\"平台\"帐号服务条款，即表示用户与\"平台\"已达成协议，自愿接受本服务条款的所有内容。此后，用户不得以未阅读本服务条款内容作任何形式的抗辩。 服务条款的确认和接纳 \"平台\"下所属产品的所有权以及相关软件的知识产权归\"平台\"所有。\"平台\"所提供的服务必须按照其发布的章程，服务条款和操作规则严格执行。本服务条款的效力范围及于\"平台\"的一切产品和服务，用户在享受\"平台\"任何服务时，应当受本服务条款的约束。 \"平台\"帐号服务简介 本服务条款所称的\"平台\"帐号是指用户以邮箱注册的合法、有效的帐号。 \"平台\"运用自己的服务器通过国际互联网络为用户提供各项服务。用户必须： 提供设备，如个人电脑、手机或其他上网设备。 个人上网和数据申请使用，需支付与此服务有关的费用。 \"平台\"帐号注册规则 \"平台\"帐号注册资料包括但不限于邮箱、用户名、头像、密码、注册或更新\"平台\"帐号时输入的所有信息。 用户在注册\"平台\"帐号时承诺遵守法律法规、社会主义制度、国家利益、公民合法权益、公共秩序、社会道德风尚和信息真实性等七条底线，不得在\"平台\"帐号注册资料中出现违法和不良信息，且用户保证其在注册和使用帐号时，不得有以下情形： 违反宪法或法律法规规定的； 危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的； 损害国家荣誉和利益的，损害公共利益的； 煽动民族仇恨、民族歧视，破坏民族团结的； 破坏国家宗教政策，宣扬邪教和封建迷信的； 散布谣言，扰乱社会秩序，破坏社会稳定的； 散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的； 侮辱或者诽谤他人，侵害他人合法权益的； 含有法律、行政法规禁止的其他内容的。 根据相关法律、法规规定以及考虑到\"平台\"产品服务的重要性，用户同意在享用\"平台\"各项服务的同时，接受\"平台\"提供的各类信息服务。 为使用户及时、全面了解\"平台\"提供的各项服务，用户同意，\"平台\"可以多次、长期向用户发送各类信息而无需另行获得用户的同意。 用户同意与注册、使用\"平台\"帐号相关的一切资料、数据和记录，包括但不限于\"平台\"帐号、注册资料、所有登录和相关的使用统计数字等归\"平台\"所有。发生争议时，用户同意以\"平台\"的系统数据为准，\"平台\"保证该数据的真实性。 服务条款的修改 \"平台\"有权在必要时通过在网页上发出公告等合理方式修改本服务相关条款。用户在享受各项服务时，应当及时查阅了解修改的内容，并自觉遵守本服务相关条款。用户如继续使用本服务条款涉及的服务，则视为对修改内容的同意，当发生有关争议时，以最新的服务条款为准；用户在不同意修改内容的情况下，有权停止使用本服务条款涉及的服务。 服务的变更或中止 \"平台\"始终在不断变更和改进服务。\"平台\"可能会增加或删除功能，也可能暂停或彻底停止某项服务。用户同意\"平台\"有权行使上述权利且不需对用户或第三方承担任何责任。 用户隐私制度 尊重用户隐私是\"平台\"的一项基本政策。\"平台\"将按照\"平台\"网站上公布的隐私政策收集、存储、使用、披露和保护您的个人信息。请您完整阅读上述隐私权政策，以帮助您更好地保护您的个人信息。 用户的帐号、密码和安全性 用户一旦注册成功成为用户，用户可随时改变用户的密码，也可以结束旧的帐户重开一个新帐户。用户应维持密码及帐号的机密安全，如果用户未保管好自己的帐号和密码而对用户、\"平台\"或第三方造成损害，用户将负全部责任。用户同意若发现任何非法使用用户帐号或安全漏洞的情况，有义务立即通告\"平台\"。 不可抗力条款 \"平台\"对不可抗力导致的损失不承担责任。本服务条款所指不可抗力包括：天灾、法律法规或政府指令的变更，因网络服务特性而特有的原因，例如境内外基础电信运营商的故障、计算机或互联网相关技术缺陷、互联网覆盖范围限制、计算机病毒、黑客攻击等因素，及其他合法范围内的不能预见、不能避免并不能克服的客观情况。 禁止服务的商业化 用户承诺，未经\"平台\"同意，用户不能利用\"平台\"各项服务进行销售或其他商业用途。如用户有需要将服务用于商业用途，应书面通知\"平台\"并获得\"平台\"的明确授权。 用户管理 用户独立承担其发布内容的责任。用户对服务的使用必须遵守所有适用于服务的地方法律、国家法律和国际法律。用户承诺： 用户在\"平台\"的网页上分享信息和发布评论或者利用\"平台\"的服务时必须符合中国有关法规，不得在\"平台\"的网页上或者利用\"平台\"的服务制作、复制、发布、传播以下信息： (a) 违反宪法确定的基本原则的； (b) 危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的； (c) 损害国家荣誉和利益的； (d) 煽动民族仇恨、民族歧视，破坏民族团结的； (e) 破坏国家宗教政策，宣扬邪教和封建迷信的； (f) 散布谣言，扰乱社会秩序，破坏社会稳定的； (g) 散布淫秽、色情、赌博、暴力、恐怖或者教唆犯罪的； (h) 侮辱或者诽谤他人，侵害他人合法权益的； (i) 煽动非法集会、结社、游行、示威、聚众扰乱社会秩序的； (j) 以非法民间组织名义活动的； (k) 含有法律、行政法规禁止的其他内容的。 用户在\"平台\"的网页上分享信息和发布评论或者利用\"平台\"的服务时还必须符合其他有关国家和地区的法律规定以及国际法的有关规定。用户需遵守法律法规的规定使用\"平台\"分享信息和发布评论。 用户不得利用\"平台\"的服务从事以下活动： (a) 未经允许，进入计算机信息网络或者使用计算机信息网络资源的； (b) 未经允许，对计算机信息网络功能进行删除、修改或者增加的； (c) 未经允许，对进入计算机信息网络中存储、处理或者传输的数据和应用程序进行删除、修改或者增加的； (d) 故意制作、传播计算机病毒等破坏性程序的； (e) 其他危害计算机信息网络安全的行为。 用户不得以任何方式干扰\"平台\"的服务。 用户不得滥用\"平台\"服务，包括但不限于利用\"平台\"服务进行侵害他人知识产权或者合法利益的其他行为。 用户应遵守\"平台\"的所有其他规定和程序。 用户须对自己在使用\"平台\"服务过程中的行为承担法律责任。用户承担法律责任的形式包括但不限于：对受到侵害者进行赔偿，以及在\"平台\"首先承担了因用户行为导致的行政处罚或侵权损害赔偿责任后，用户应给予\"平台\"等额的赔偿。若用户违反以上规定，\"平台\"有权作出独立判断立即暂停或终止对用户提供部分或全部服务，包括锁定、注销、删除用户\"平台\"帐号等措施。用户理解，如果\"平台\"发现其网站传输的信息明显属于上段第(1)条所列内容之一，依据中国法律，\"平台\"有义务立即停止传输，保存有关记录，向国家有关机关报告，并且删除含有该内容的地址、目录或关闭服务器。 保障 用户同意保障和维护\"平台\"全体成员的利益，承担由用户违反服务条款的损害补偿费用，其它人使用用户的电脑、帐号而产生的费用。 如用户或其它网络服务提供者利用\"平台\"的服务侵害他人民事权益的，应当承担侵权等法律责任。 如用户利用\"平台\"的服务实施侵权行为的，被侵权人有权通知\"平台\"采取删除、屏蔽、断开链接等必要措施。\"平台\"接到通知后，因自身过错若未及时采取必要措施的，按法律规定承担责任。 通知 所有发给用户的通知都可通过电子邮件、通知或在网站显著位置公告的方式进行传送。\"平台\"将通过上述方法之一将消息传递给用户，告知他们服务条款的修改、服务变更、或其它重要事情。同时，\"平台\"保留利用\"平台\"发布商业性广告的权利，包括但不限于在\"平台\"的登录页面及登录后任何页面内放置商业广告、向\"平台\"的用户发送商业性广告邮件以及在\"平台\"的用户发出的电子邮件内附上商业性广告及／或广告链接等形式。 内容、商标的所有权 \"平台\"提供的内容包括但不限于：非用户上传/提供的文字、软件、声音、相片、视频、图表等。所有这些内容均属于\"平台\"，并受版权、商标、专利和其它财产所有权法律的保护。所以，用户只能在\"平台\"授权下才能使用这些内容，而不能擅自复制、再造这些内容、或创造与内容有关的派生产品。 \"平台\"，以及\"平台\"的其他标志及\"平台\"产品、服务的名称，均为\"平台\"之商标（以下简称\"平台\"标识）。未经\"平台\"事先书面同意，您不得将\"平台\"标识以任何方式展示或使用或作其他处理，也不得向他人表明您有权展示、使用、或其他有权处理\"平台\"标识的行为。 法律 本条款适用中华人民共和国的法律，并且排除一切冲突法规定的适用。 如出现纠纷，用户和\"平台\"一致同意将纠纷交由本协议签订地有管辖权人民法院受理。本协议签订地为上海市浦东新区。 信息储存及相关知识产权 \"平台\"对\"平台\"帐号上所有服务将尽力维护其安全性及方便性，但对服务中出现的信息（包括但不限于用户发布的信息）删除或储存失败不承担任何责任。另外\"平台\"有权判定用户的行为是否符合本服务条款的要求，如果用户违背了本服务条款的规定，\"平台\"有权中止或者终止对其\"平台\"帐号的服务。 \"平台\"尊重知识产权并注重保护用户享有的各项权利。在\"平台\"帐号所含服务中，用户可能需要通过上传、发布等各种方式向\"平台\"提供内容。在此情况下，用户仍然享有此等内容的完整知识产权。用户在提供内容时将授予\"平台\"一项全球性的免费许可，允许\"平台\"使用、传播、复制、修改、再许可、翻译、创建衍生作品及展示此等内容。 青少年用户特别提示 青少年用户必须遵守全国青少年网络文明公约： 要善于网上学习，不浏览不良信息；要诚实友好交流，不侮辱欺诈他人；要增强自护意识，不随意约会网友；要维护网络安全，不破坏网络秩序；要有益身心健康，不沉溺虚拟时空。 \"平台\"帐号的有效期 用户清楚知悉\"平台\"帐号存在有效期，并同意不定时登录使用\"平台\"帐号以延续其有效期。 一般情况： 如果用户的\"平台\"帐号连续180天没有登录，则\"平台\"有权删除该帐号；如该用户以\"平台\"免费注册的帐号，\"平台\"还有权立即终止该帐号下的服务并将内容删除； 如果用户的\"平台\"帐号连续180天没有登录，如该用户以\"平台\"免费注册的帐号，\"平台\"有权立即终止该帐号下的服务并将内容删除；如该帐号连续365天没有登录，则该帐号最后一次登录之日起的第365天到期作废，\"平台\"有权删除该帐号。 当帐号被删除后，该\"平台\"帐号的所有资料以及与该\"平台\"帐号相关的全部服务资料和数据（包括但不限于账号信息、工作空间Workspace、NoteBooks、API服务等）将被同时删除，且不可恢复。 登录\"平台\"是指通过Web网站方式使用帐号密码成功登录\"平台\"。 其他 \"平台\"不行使、未能及时行使或者未充分行使本条款或者按照法律规定所享有的权利，不应被视为放弃该权利，也不影响\"平台\"在将来行使该权利。 如本条款中的任何条款无论因何种原因完全或部分无效或不具有执行力，本服务条款的其余条款仍应有效且具有约束力，\"平台\"及用户均应尽力使该条款设定的本意得到实现。 本条款中的标题仅为方便而设，不作为解释本条款的依据。 如用户对本条款内容有任何疑问，可联系feedback@smartnotebook.tech给我们提建议。 "},"About.html":{"url":"About.html","title":"关于","keywords":"","body":"关于 联系方式 地址：上海市浦东新区郭守敬路498号28号楼 联系人：王先生 电话：198-2133-7583 邮箱：wangxinyi@smartnotebook.tech 微信公众号 头条号 知乎号 产品咨询 微信扫描下方二维码，我们的工作人员会尽快联系您： "}}